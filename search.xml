<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM专项-第四篇</title>
      <link href="/2023/06/04/JVM-04/"/>
      <url>/2023/06/04/JVM-04/</url>
      
        <content type="html"><![CDATA[<div class="note default simple"><p>JAVA虚拟机专项</p></div><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-06-04 [ 1.0 ]</p></div></div><div class='timeline-item-content'><p>首次发布</p></div></div></div><h1 id="JVM优化思路"><a href="#JVM优化思路" class="headerlink" title="JVM优化思路"></a>JVM优化思路</h1><p>大型电商系统后端现在一般都是拆分为多个子系统部署的，比如，商品系统，库存系统，订单系统，促销系统，会员系统等等。我们这里以比较核心的订单系统为例</p><p><img src="/blog-img/1665042437463.png" style="zoom:100%;" /><br>对于8G内存，我们一般是分配4G内存给JVM，正常的JVM参数配置如下： </p><blockquote><p>-Xms3072M -Xmx3072M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:SurvivorRatio=8</p></blockquote><p><img src="/blog-img/1665043827736.png" style="zoom:90%;" /></p><p>这样设置可能会由于动态对象年龄判断原则导致频繁full gc。于是我们可以更新下JVM参数设置：</p><blockquote><p>-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:SurvivorRatio=8</p></blockquote><p><img src="/blog-img/1665043841101.png" style="zoom:80%;" /><br>这样就降低了因为对象动态年龄判断原则导致的对象频繁进入老年代的问题，其实<span class='p blue'>很多优化无非就是让短期存活的对象尽量都留在survivor里，不要进入老年代，这样在minor gc的时候这些对象都会被回收，不会进到老年代从而导致full gc。</span></p><p>对于对象年龄应该为多少才移动到老年代比较合适，本例中一次minor gc要间隔二三十秒，大多数对象一般在几秒内就会变为垃圾，完全可以将默认的15岁改小一点，比如改为5，那么意味着对象要经过5次minor gc才会进入老年代，整个时间也有一两分钟了，如果对象这么长时间都没被回收，完全可以认为这些对象是会存活的比较长的对象，可以移动到老年代，而不是继续一直占用survivor区空间。</p><p>对于多大的对象直接进入老年代(参数-XX:PretenureSizeThreshold)，这个一般可以结合你自己系统看下有没有什么大对象生成，预估下大对象的大小，一般来说设置为1M就差不多了，很少有超过1M的大对象，这些对象一般就是你系统初始化分配的缓存对象，比如大的缓存List，Map之类的对象。</p><p>可以适当调整JVM参数如下：</p><blockquote><p>-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M</p></blockquote><p>对于JDK8默认的垃圾回收器是-XX:+UseParallelGC(年轻代)和-XX:+UseParallelOldGC(老年代)，如果内存较大(超过4个G，只是经验值)，系统对停顿时间比较敏感，我们可以使用ParNew+CMS。对于老年代CMS的参数如何设置我们可以思考下，首先我们想下当前这个系统有哪些对象可能会长期存活躲过5次以上minor gc最终进入老年代。无非就是那些Spring容器里的Bean，线程池对象，一些初始化缓存数据对象等，这些加起来充其量也就几十MB。还有就是某次minor gc完了之后还有超过一两百M的对象存活，那么就会直接进入老年代，比如突然某一秒瞬间要处理五六百单，那么每秒生成的对象可能有一百多M，再加上整个系统可能压力剧增，一个订单要好几秒才能处理完，下一秒可能又有很多订单过来。</p><p>我们可以估算下大概每隔五六分钟出现一次这样的情况，那么大概半小时到一小时之间就可能因为老年代满了触发一次Full GC，Full GC的触发条件还有我们之前说过的老年代空间分配担保机制，历次的minor gc挪动到老年代的对象大小肯定是非常小的，所以几乎不会在minor gc触发之前由于老年代空间分配担保失败而产生full gc，其实在半小时后发生full gc，这时候已经过了抢购的最高峰期，后续可能几小时才做一次FullGC。对于碎片整理，因为都是1小时或几小时才做一次FullGC，是可以每做完一次就开始碎片整理，或者两到三次之后再做一次也行。</p><p><strong>综上，只要年轻代参数设置合理，老年代CMS的参数设置基本都可以用默认值</strong>，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM专项-第三篇</title>
      <link href="/2023/06/04/JVM-03/"/>
      <url>/2023/06/04/JVM-03/</url>
      
        <content type="html"><![CDATA[<div class="note default simple"><p>JAVA虚拟机专项</p></div><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-06-04 [ 1.0 ]</p></div></div><div class='timeline-item-content'><p>首次发布</p></div></div></div><h1 id="垃圾对象判断算法"><a href="#垃圾对象判断算法" class="headerlink" title="垃圾对象判断算法"></a>垃圾对象判断算法</h1><h2 id="引用计数法（基本不用）"><a href="#引用计数法（基本不用）" class="headerlink" title="引用计数法（基本不用）"></a>引用计数法（基本不用）</h2><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGc</span> &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ReferenceCountingGc</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">      <span class="type">ReferenceCountingGc</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">      objA.instance = objB;</span><br><span class="line">      objB.instance = objA;</span><br><span class="line">      objA = <span class="literal">null</span>;</span><br><span class="line">      objB = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>将“GC Roots” 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的对象都是垃圾对象</p><p>GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等<br><img src="/blog-img/1665040109598.png" style="zoom:90%;" /></p><hr><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如在新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。</p><h2 id="标记-复制算法（幸存区使用）"><a href="#标记-复制算法（幸存区使用）" class="headerlink" title="标记-复制算法（幸存区使用）"></a>标记-复制算法（幸存区使用）</h2><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。<br><img src="/blog-img/1665040642333.png" style="zoom:80%;" /></p><blockquote><p>缺陷是内存利用率只有50%</p></blockquote><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>算法分为“标记”和“清除”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个明显的问题：</p><ul><li><ol><li>效率问题  (如果需要标记的对象太多，效率不高)</li></ol></li><li><ol><li>空间问题（标记清除后会产生大量不连续的碎片）</li></ol></li></ul><p><img src="/blog-img/1665040666595.png" style="zoom:90%;" /></p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。<br><img src="/blog-img/1665040707073.png" style="zoom:90%;" /></p><hr><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><img src="/blog-img/1665041148795.png" style="zoom:100%;" /><br><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加<strong>没有万能的垃圾收集器</strong>，我们能做的就是<strong>根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的Java虚拟机就不会实现那么多不同的垃圾收集器了。</p><h2 id="Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC"><a href="#Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC" class="headerlink" title="Serial收集器(-XX:+UseSerialGC  -XX:+UseSerialOldGC)"></a>Serial收集器(-XX:+UseSerialGC  -XX:+UseSerialOldGC)</h2><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</p><blockquote><p>新生代采用复制算法，老年代采用标记-整理算法。</p></blockquote><p><img src="/blog-img/1665041221435.png" style="zoom:100%;" /><br>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效</strong>（与其他收集器的单线程相比）。Serial收集器由于<strong>没有线程交互的开销，自然可以获得很高的单线程收集效率</strong>。</p><p><strong>Serial Old</strong>收集器是Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是<strong>作为CMS收集器的后备方案</strong>。</p><h2 id="Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代"><a href="#Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代" class="headerlink" title="Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))"></a>Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))</h2><p><strong>Parallel收集器其实就是Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。</p><p><strong>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）</strong>。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><img src="/blog-img/1665041343364.png" style="zoom:100%;" /></p><blockquote><p><strong>Parallel Old收集器是Parallel Scavenge收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器(JDK8默认的新生代和老年代收集器)。</p></blockquote><h2 id="ParNew收集器-XX-UseParNewGC"><a href="#ParNew收集器-XX-UseParNewGC" class="headerlink" title="ParNew收集器(-XX:+UseParNewGC)"></a>ParNew收集器(-XX:+UseParNewGC)</h2><p>ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。<br>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><h2 id="XX-UseConcMarkSweepGC-old"><a href="#XX-UseConcMarkSweepGC-old" class="headerlink" title="(-XX:+UseConcMarkSweepGC(old))"></a><span class='p red'>CMS收集器</span>(-XX:+UseConcMarkSweepGC(old))</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃<br><img src="/blog-img/1665041441317.png" style="zoom:100%;" /><br>从它的名字就可以看出它是一款优秀的垃圾收集器，<strong>主要优点：并发收集、低停顿。</strong>但是它有下面几个明显的缺点：</p><ul><li><p>对CPU资源敏感（会和服务抢资源）；</p></li><li><p><strong>无法处理浮动垃圾</strong>(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</p></li><li><p>它使用的回收算法-“<strong>标记-清除</strong>”算法会导致收集结束时会有<strong>大量空间碎片</strong>产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</p></li><li><p><strong>执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况</strong>，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”concurrent mode failure（并发模式失败）”，此时会进入stop the world，用serial old垃圾收集器来回收</p><blockquote><p><strong>上述现象的原因是因为垃圾对象特别多，导致回收过程特别慢，最终导致这次还没有回收完成，下次垃圾回收又被触发了。导致垃圾对象很多的情况，基本是内存特别大。所以CMS不适合大内存情况（超过4G的堆内存一般选择G1）</strong></p></blockquote></li></ul><details class="folding-tag" ><summary> 多标&漏标 </summary>              <div class='content'>              <p><img src="/blog-img/1665301845787.png" alt=""></p>              </div>            </details><p><strong>CMS的相关核心参数</strong></p><ul><li>-XX:+UseConcMarkSweepGC：启用cms</li><li>-XX:ConcGCThreads：并发的GC线程数</li><li>-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片）</li><li>-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次</li><li>-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）</li><li>-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整</li><li>-XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，降低CMS GC标记阶段(也会对年轻代一起做标记，如果在minor gc就干掉了很多对垃圾对象，标记阶段就会减少一些标记时间)时的开销，一般CMS的GC耗时 80%都在标记阶段</li><li>-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW</li><li>-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a><span class='p blue'>G1收集器(-XX:+UseG1GC)</span></h2><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</p><blockquote><p>用户可以设置能够容忍的stw时间</p></blockquote><p><img src="/blog-img/1665044465984.png" style="zoom:100%;" /><br>G1将Java堆划分为多个大小相等的独立区域（Region），JVM目标是不超过2048个Region(JVM源码里TARGET_REGION_NUMBER 定义)，实际可以超过该值，但是不推荐。</p><p>一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以用参数”-XX:G1HeapRegionSize”手动指定Region大小，但是推荐默认的计算方式。</p><p>G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。</p><p>默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个Region，可以通过“-XX:G1NewSizePercent”设置新生代初始占比，在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“-XX:G1MaxNewSizePercent”调整。年轻代中的Eden和Survivor对应的region也跟之前一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应100个。</p><p>一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。</p><p>G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，唯一不同的是对大对象的处理，G1有专门分配大对象的Region叫Humongous区，而不是让大对象直接进入老年代的Region中。在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。</p><p>Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。</p><p>Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。</p><p><strong>G1收集器一次GC(主要值Mixed GC)的运作过程大致分为以下几个步骤：</strong></p><ul><li><strong>初始标记</strong>（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快 ；</li></ul><ul><li><strong>并发标记</strong>（Concurrent Marking）：同CMS的并发标记</li><li><strong>最终标记</strong>（Remark，STW）：同CMS的重新标记</li><li><strong>筛选回收</strong>（Cleanup，STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿STW时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划，比如说老年代此时有1000个Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(Collection Set，要回收的集合)，尽量把GC导致的停顿时间控制在我们指定的范围内。这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。不管是年轻代或是老年代，回收算法主要用的是复制算法，将一个region中的存活对象复制到另一个region中，这种不会像CMS那样回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片。(注意：CMS回收阶段是跟用户线程一起并发执行的，G1因为内部实现太复杂暂时没实现并发回收，不过到了ZGC，Shenandoah就实现了并发收集，Shenandoah可以看成是G1的升级版本</li></ul><p><img src="/blog-img/1665044537247.png" style="zoom:100%;" /><br><strong>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)，比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率。</p><p><strong>被视为JDK1.7以上版本Java虚拟机的一个重要进化特征。它具备以下特点：</strong></p><ul><li><strong>并行与并发</strong>：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段(通过参数”-XX:MaxGCPauseMillis”指定)内完成垃圾收集。</li></ul><p>毫无疑问， 可以由用户指定期望的停顿时间是G1收集器很强大的一个功能， 设置不同的期望停顿时间， 可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。 不过， 这里设置的“期望值”必须是符合实际的， 不能异想天开， 毕竟G1是要冻结用户线程来复制对象的， 这个停顿时间再怎么低也得有个限度。 它默认的停顿目标为两百毫秒， 一般来说， 回收阶段占到几十到一百甚至接近两百毫秒都很正常， 但如果我们把停顿时间调得非常低， 譬如设置为二十毫秒， 很可能出现的结果就是由于停顿目标时间太短， 导致每次选出来的回收集只占堆内存很小的一部分， 收集器收集的速度逐渐跟不上分配器分配的速度， 导致垃圾慢慢堆积。 很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间， 但应用运行时间一长就不行了， 最终占满堆引发Full GC反而降低性能， 所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。</p><h3 id="G1垃圾收集分类"><a href="#G1垃圾收集分类" class="headerlink" title="G1垃圾收集分类"></a>G1垃圾收集分类</h3><ul><li><p><strong>YoungGC</strong><br>YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC</p></li><li><p><strong>MixedGC</strong><br>不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC</p></li><li><p><strong>Full GC</strong><br>停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了)</p></li></ul><h3 id="G1收集器参数设置"><a href="#G1收集器参数设置" class="headerlink" title="G1收集器参数设置"></a>G1收集器参数设置</h3><ul><li><p>-XX:+UseG1GC:使用G1收集器</p></li><li><p>-XX:ParallelGCThreads:指定GC工作的线程数量</p></li><li><p>-XX:G1HeapRegionSize:指定分区大小(1MB~32MB，且必须是2的N次幂)，默认将整堆划分为2048个分区</p></li><li><p>-XX:MaxGCPauseMillis:目标暂停时间(默认200ms)</p></li><li><p>-XX:G1NewSizePercent:新生代内存初始空间(默认整堆5%，值配置整数，默认就是百分比)</p></li><li><p>-XX:G1MaxNewSizePercent:新生代内存最大空间</p></li><li><p>-XX:TargetSurvivorRatio:Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代</p></li><li><p>-XX:MaxTenuringThreshold:最大年龄阈值(默认15)</p></li><li><p>-XX:InitiatingHeapOccupancyPercent:老年代占用空间达到整堆内存阈值(默认45%)，则执行新生代和老年代的混合收集(MixedGC)，比如我们之前说的堆默认有2048个region，如果有接近1000个region都是老年代的region，则可能就要触发MixedGC了</p></li><li><p>-XX:G1MixedGCLiveThresholdPercent(默认85%)  region中的存活对象低于这个值时才会回收该region，如果超过这个值，存活对象过多，回收的的意义不大。</p></li><li><p>-XX:G1MixedGCCountTarget:在一次回收过程中指定做几次筛选回收(默认8次)，在最后一个筛选回收阶段可以回收一会，然后暂停回收，恢复系统运行，一会再开始回收，这样可以让系统不至于单次停顿时间过长。</p></li><li><p>-XX:G1HeapWastePercent(默认5%): gc过程中空出来的region是否充足阈值，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。</p></li></ul><h3 id="G1垃圾收集器优化建议"><a href="#G1垃圾收集器优化建议" class="headerlink" title="G1垃圾收集器优化建议"></a>G1垃圾收集器优化建议</h3><p>假设参数 -XX:MaxGCPauseMills 设置的值很大，导致系统运行很久，年轻代可能都占用了堆内存的60%了，此时才触发年轻代gc。</p><p>那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中。</p><p>或者是你年轻代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor区域的50%，也会快速导致一些对象进入老年代中。</p><p>所以这里核心还是在于调节 -XX:MaxGCPauseMills 这个参数的值，在保证他的年轻代gc别太频繁的同时，还得考虑每次gc过后的存活对象有多少,避免存活对象太多快速进入老年代，频繁触发mixed gc.</p><h3 id="G1使用场景"><a href="#G1使用场景" class="headerlink" title="G1使用场景"></a>G1使用场景</h3><ol><li>50%以上的堆被存活对象占用</li><li>对象分配和晋升的速度变化非常大</li><li>垃圾回收时间特别长，超过1秒</li><li>8GB以上的堆内存(建议值)</li><li>停顿时间是500ms以内</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kafka类似的支撑高并发消息系统大家肯定不陌生，对于kafka来说，每秒处理几万甚至几十万消息时很正常的，一般来说部署kafka需要用大内存机器(比如64G)，也就是说可以给年轻代分配个三四十G的内存用来支撑高并发处理，这里就涉及到一个问题了，我们以前常说的对于eden区的young gc是很快的，这种情况下它的执行还会很快吗？很显然，不可能，因为内存太大，处理还是要花不少时间的，假设三四十G内存回收可能最快也要几秒钟，按kafka这个并发量放满三四十G的eden区可能也就一两分钟吧，那么意味着整个系统每运行一两分钟就会因为young gc卡顿几秒钟没法处理新消息，显然是不行的。那么对于这种情况如何优化了，我们可以使用G1收集器，设置 -XX:MaxGCPauseMills 为50ms，假设50ms能够回收三到四个G内存，然后50ms的卡顿其实完全能够接受，用户几乎无感知，那么整个系统就可以在卡顿几乎无感知的情况下一边处理业务一边收集垃圾。</span><br><span class="line">G1天生就适合这种大内存机器的JVM运行，可以比较完美的解决大内存垃圾回收时间过长的问题。</span><br></pre></td></tr></table></figure><h2 id="ZGC收集器-XX-UseZGC"><a href="#ZGC收集器-XX-UseZGC" class="headerlink" title="ZGC收集器(-XX:+UseZGC)"></a>ZGC收集器(-XX:+UseZGC)</h2><p>参考文章：</p><ul><li><a href="https://wiki.openjdk.java.net/display/zgc/Main">https://wiki.openjdk.java.net/display/zgc/Main</a></li><li><a href="http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf">http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf</a></li></ul><p>ZGC是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器，ZGC可以说源自于是Azul System公司开发的C4（Concurrent Continuously Compacting Collector） 收集器。</p><h3 id="ZGC目标"><a href="#ZGC目标" class="headerlink" title="ZGC目标"></a>ZGC目标</h3><p>如下图所示，ZGC的目标主要有4个：<br><img src="/blog-img/1665044801660.png" style="zoom:100%;" /></p><ul><li><strong>支持TB量级的堆</strong>。我们生产环境的硬盘还没有上TB呢，这应该可以满足未来十年内，所有JAVA应用的需求了吧。</li><li><strong>最大GC停顿时间不超10ms</strong>。目前一般线上环境运行良好的JAVA应用Minor GC停顿时间在10ms左右，Major GC一般都需要100ms以上（G1可以调节停顿时间，但是如果调的过低的话，反而会适得其反），之所以能做到这一点是因为它的停顿时间主要跟Root扫描有关，而Root数量和堆大小是没有任何关系的。</li><li><strong>奠定未来GC特性的基础</strong>。</li><li><strong>最糟糕的情况下吞吐量会降低15%</strong>。这都不是事，停顿时间足够优秀。至于吞吐量，通过扩容分分钟解决。</li></ul><p>另外，Oracle官方提到了它最大的优点是：它的停顿时间不会随着堆的增大而增长！也就是说，几十G堆的停顿时间是10ms以下，几百G甚至上T堆的停顿时间也是10ms以下。</p><hr><h1 id="三色标记（了解）"><a href="#三色标记（了解）" class="headerlink" title="三色标记（了解）"></a>三色标记（了解）</h1><p>在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，<strong>多标和漏标</strong>的情况就有可能发生。漏标的问题主要引入了三色标记算法来解决。</p><p>三色标记算法是把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：</p><ul><li><strong>黑色</strong>： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。</li></ul><ul><li><strong>灰色</strong>： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。</li></ul><ul><li><strong>白色</strong>： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。</li></ul><p><img src="/blog-img/1665044219471.png" style="zoom:100%;" /></p><h2 id="多标-浮动垃圾"><a href="#多标-浮动垃圾" class="headerlink" title="多标-浮动垃圾"></a>多标-浮动垃圾</h2><p>在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gcroot引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。</p><p>另外，针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。</p><h2 id="漏标-读写屏障"><a href="#漏标-读写屏障" class="headerlink" title="漏标-读写屏障"></a>漏标-读写屏障</h2><p><strong>漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案： 增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB）</strong> 。</p><p>增量更新就是当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。</p><p>原始快照就是当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)</p><blockquote><p>以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM专项-第二篇</title>
      <link href="/2023/06/04/JVM-02/"/>
      <url>/2023/06/04/JVM-02/</url>
      
        <content type="html"><![CDATA[<div class="note default simple"><p>JAVA虚拟机专项</p></div><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-06-04 [ 1.0 ]</p></div></div><div class='timeline-item-content'><p>首次发布</p></div></div></div><h1 id=""><a href="#" class="headerlink" title=""></a><span class='p red'>对象内存分配</span></h1><p><img src="/blog-img/1665037570397.png" style="zoom:80%;" /></p><h2 id="对象栈上分配"><a href="#对象栈上分配" class="headerlink" title="对象栈上分配"></a>对象栈上分配</h2><p>我们通过JVM内存分配可以知道JAVA中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM通过<strong>逃逸分析</strong>确定该对象不会被外部访问。如果不会逃逸可以将该对象在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p><ul><li><strong>对象逃逸分析：</strong>就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</li></ul><p><img src="/blog-img/1665037733058.png" style="zoom:100%;" /><br>很显然test1方法中的user对象被返回了，这个对象的作用域范围不确定，test2方法中的user对象我们可以确定当方法结束这个对象就可以认为是无效对象了，对于这样的对象我们其实可以将其分配在栈内存里，让其在方法结束时跟随栈内存一起被回收掉。JVM对于这种情况可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过标量替换优先分配在栈上(栈上分配)，JDK7之后默认开启逃逸分析，如果要关闭使用参数(-XX:-DoEscapeAnalysis)</p><ul><li><strong>标量替换：</strong>通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认开启。</li><li><strong>标量与聚合量：</strong>标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。<br><img src="/blog-img/1665038340530.png" style="zoom:80%;" /></li></ul><h2 id="对象在Eden区分配"><a href="#对象在Eden区分配" class="headerlink" title="对象在Eden区分配"></a>对象在Eden区分配</h2><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。我们来进行实际测试一下。</p><p>在测试之前我们先来看看 <strong>Minor GC和Full GC 有什么不同呢？</strong></p><ul><li><strong>Minor GC/Young GC：</strong>指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li><li><strong>Major GC/Full GC：</strong>一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上。</li></ul><span class='p blue'>**Eden与Survivor区默认8:1:1**</span><p>大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，<strong>让eden区尽量的大，survivor区够用即可，</strong></p><blockquote><p>JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数-XX:-UseAdaptiveSizePolicy</p></blockquote><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加运行JVM参数： -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">byte</span>[] allocation1, allocation2<span class="comment">/*, allocation3, allocation4, allocation5, allocation6*/</span>;</span><br><span class="line">      allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//allocation2 = new byte[8000*1024];</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*allocation3 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">     allocation4 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">     allocation5 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">     allocation6 = new byte[1000*1024];*/</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 65536K [0x000000076b400000, 0x0000000770900000, 0x00000007c0000000)</span><br><span class="line">  eden space 65536K, 100% used [0x000000076b400000,0x000000076f400000,0x000000076f400000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076fe80000,0x000000076fe80000,0x0000000770900000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076f400000,0x000000076f400000,0x000000076fe80000)</span><br><span class="line"> ParOldGen       total 175104K, used 0K [0x00000006c1c00000, 0x00000006cc700000, 0x000000076b400000)</span><br><span class="line">  object space 175104K, 0% used [0x00000006c1c00000,0x00000006c1c00000,0x00000006cc700000)</span><br><span class="line"> Metaspace       used 3342K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 361K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>我们可以看出eden区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用至少几M内存）。假如我们<strong>再为allocation2分配内存会出现什么情况呢？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 65253K-&gt;936K(76288K)] 65253K-&gt;60944K(251392K), 0.0279083 secs] [Times: user=0.13 sys=0.02, real=0.03 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 9591K [0x000000076b400000, 0x0000000774900000, 0x00000007c0000000)</span><br><span class="line">  eden space 65536K, 13% used [0x000000076b400000,0x000000076bc73ef8,0x000000076f400000)</span><br><span class="line">  from space 10752K, 8% used [0x000000076f400000,0x000000076f4ea020,0x000000076fe80000)</span><br><span class="line">  to   space 10752K, 0% used [0x0000000773e80000,0x0000000773e80000,0x0000000774900000)</span><br><span class="line"> ParOldGen       total 175104K, used 60008K [0x00000006c1c00000, 0x00000006cc700000, 0x000000076b400000)</span><br><span class="line">  object space 175104K, 34% used [0x00000006c1c00000,0x00000006c569a010,0x00000006cc700000)</span><br><span class="line"> Metaspace       used 3342K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 361K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p><strong>简单解释一下为什么会出现这种情况</strong>： 因为给allocation2分配内存的时候eden区内存几乎已经被分配完了，我们刚刚讲了当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，GC期间虚拟机又发现allocation1无法存入Survior空间，所以只好把新生代的<strong>对象提前转移到老年代中去</strong>，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。可以执行如下<strong>代码验证</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6;</span><br><span class="line">      allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">      allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">     allocation5 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">     allocation6 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 65253K-&gt;952K(76288K)] 65253K-&gt;60960K(251392K), 0.0311467 secs] [Times: user=0.08 sys=0.02, real=0.03 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 13878K [0x000000076b400000, 0x0000000774900000, 0x00000007c0000000)</span><br><span class="line">  eden space 65536K, 19% used [0x000000076b400000,0x000000076c09fb68,0x000000076f400000)</span><br><span class="line">  from space 10752K, 8% used [0x000000076f400000,0x000000076f4ee030,0x000000076fe80000)</span><br><span class="line">  to   space 10752K, 0% used [0x0000000773e80000,0x0000000773e80000,0x0000000774900000)</span><br><span class="line"> ParOldGen       total 175104K, used 60008K [0x00000006c1c00000, 0x00000006cc700000, 0x000000076b400000)</span><br><span class="line">  object space 175104K, 34% used [0x00000006c1c00000,0x00000006c569a010,0x00000006cc700000)</span><br><span class="line"> Metaspace       used 3343K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 361K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。</p><p>比如设置JVM参数：-XX:PretenureSizeThreshold=1000000 (单位是字节)  -XX:+UseSerialGC  ，再执行下上面的第一个程序会发现大对象直接进了老年代</p><blockquote><p>大对象直接进入老年代,这么做是为了避免为大对象分配内存时的复制操作而降低效率。</p></blockquote><h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p><h2 id="对象动态年龄判断"><a href="#对象动态年龄判断" class="headerlink" title="对象动态年龄判断"></a>对象动态年龄判断</h2><p><strong>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定百分比大小)</strong>，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了，例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年龄判断机制一般是在minor gc之后触发的</p><blockquote><p>会出现一个问题，被判断的这一批对象中，一些本应该在年轻代中GC的对象，也被加到老年代，导致老年代内存占据越来越高，full GC频率也随之增加</p></blockquote><h2 id="老年代空间分配担保机制"><a href="#老年代空间分配担保机制" class="headerlink" title="老年代空间分配担保机制"></a>老年代空间分配担保机制</h2><p>年轻代每次minor gc之前JVM都<strong>会计算下老年代剩余可用空间</strong>，如果这个<strong>可用空间小</strong>于年轻代里现有的所有对象大小之和(包括垃圾对象)，就会<strong>看一个“-XX:-HandlePromotionFailure</strong>”(jdk1.8默认就设置了)的参数是否设置了，如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小。如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放新的对象就会发生”OOM”</p><blockquote><p>当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”</p></blockquote><p><img src="/blog-img/1665040010177.png" style="zoom:80%;" /></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMM专项</title>
      <link href="/2023/06/04/JMM-01/"/>
      <url>/2023/06/04/JMM-01/</url>
      
        <content type="html"><![CDATA[<div class="note default simple"><p>JAVA内存模型专项</p></div><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-06-04 [ 1.0 ]</p></div></div><div class='timeline-item-content'><p>首次发布</p></div></div></div><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><blockquote><p>JAVA内存模型</p></blockquote><p><img src="/JMM-img/1665321288936.png" style="zoom:100%;" /></p><span class='p blue'>主内存</span><ul><li>主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，<strong>多条线程对同一个变量进行访问可能会发生线程安全问题</strong>。</li></ul><span class='p blue'>工作内存</span><ul><li>主要存储当前方法的所有本地变量信息(<strong>工作内存中存储着主内存中的变量副本拷贝</strong>)，<strong>每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的</strong>，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。<br>根据JVM虚拟机规范主内存与工作内存的数据存储类型以及操作方式，对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。<strong>但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中</strong>。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存</li></ul><p><img src="/JMM-img/1665321605314.png" style="zoom:100%;" /></p><span class='p blue'>Java内存模型与硬件内存架构的关系</span><ul><li>Java内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响，因为JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。(注意对于Java内存区域划分也是同样的道理)</li></ul><p><img src="/JMM-img/1665321764475.png" style="zoom:100%;" /></p><hr><h1 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><blockquote><p>  线程在操作数据时，如果一个线程从上到下操作过程不被中断，称之为是原子性的。如果被中断，那么是非原子性的。线程在执行过程中，需要依赖于cpu的执行权的，cpu是随机抢夺的。哪个线程抢到就由哪个执行。所以线程在执行代码过程中无法保证不被中断。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.qf;</span><br><span class="line"></span><br><span class="line">public class AtomicTest &#123;</span><br><span class="line">    private int i = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        AtomicTest atomicTest = new AtomicTest();</span><br><span class="line"></span><br><span class="line">        Thread threadA = new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                atomicTest.i++;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(20);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                atomicTest.i++;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(50);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicTest.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可见行"><a href="#可见行" class="headerlink" title="可见行"></a>可见行</h2><blockquote><p>  由于JMM内存模型的原因，每个线程都有自己的工作内存，各个线程工作内存间的数据操作彼此是不可见的。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.qf;</span><br><span class="line"></span><br><span class="line">public class VisiableTest &#123;</span><br><span class="line">    boolean initFlag = false;</span><br><span class="line">    public void save()&#123;</span><br><span class="line">        this.initFlag = true;</span><br><span class="line">        String threadname = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(&quot;线程：&quot;+threadname+&quot;:修改共享变量initFlag为true&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void load()&#123;</span><br><span class="line">        String threadname = Thread.currentThread().getName();</span><br><span class="line">        while (!initFlag)&#123;</span><br><span class="line">            //线程在此处空跑，等待initFlag状态改变</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程：&quot;+threadname+&quot;当前线程嗅探到initFlag的状态的改变&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        VisiableTest sample = new VisiableTest();</span><br><span class="line">        Thread threadA = new Thread(()-&gt;&#123;</span><br><span class="line">            sample.save();</span><br><span class="line">        &#125;,&quot;threadA&quot;);</span><br><span class="line">        Thread threadB = new Thread(()-&gt;&#123;</span><br><span class="line">            sample.load();</span><br><span class="line">        &#125;,&quot;threadB&quot;);</span><br><span class="line">        threadB.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><blockquote><p>  编译器或者cpu执行过程中可能会发生编译重拍或者指令重拍。这种重排是编译器或者cpu内部针对执行过程进行的优化，单线程环境下，不管重排与否，最终都不能影响程序的执行结果（这个是由happens-before原则保障的），但是在多线程环境下，一旦重排就可能出现bug</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.qf;</span><br><span class="line"></span><br><span class="line">public class SequenceTest &#123;</span><br><span class="line">    private volatile static int a,b,x,y;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            a = 0;</span><br><span class="line">            b = 0;</span><br><span class="line">            x = 0;</span><br><span class="line">            y = 0;</span><br><span class="line"></span><br><span class="line">            Thread t1 = new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                        Thread.sleep(20);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    a = 1;</span><br><span class="line">                    x = b;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">            Thread t2 = new Thread(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                        Thread.sleep(20);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    b = 1;</span><br><span class="line">                    y = a;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;第&quot;+i+&quot;次执行: (x=&quot;+x+&quot;,y=&quot;+y+&quot;)&quot;);</span><br><span class="line"></span><br><span class="line">            if (x==0 &amp;&amp; y==0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><blockquote><p>解决可见性和有序性，不能解决原子性</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>volatile修饰的变量生成汇编语言时，会在变量上添加lock前缀。</strong>计算机在执行这个汇编指令时，遇到lock前缀，一方面会触发<strong>缓存一致性协议</strong>，保证各个cpu中缓存的某个缓存行数据的一致性，从而<strong>保证</strong>多线程间数据的<strong>可见性</strong>；另一方面会基于<strong>内存屏障</strong>， 保证被volatile修饰的变量在编译、执行过程中不会被重排序，从而<strong>保证</strong>多线程执行过程中的程序<strong>有序性</strong>。</p><h2 id="缓存一致性协议（MESI）"><a href="#缓存一致性协议（MESI）" class="headerlink" title="缓存一致性协议（MESI）"></a>缓存一致性协议（MESI）</h2><blockquote><p>强制将最新修改同步到主存，并且强制其他cpu缓存更新最新的缓存行数据，从而保证数据一致（可见）</p></blockquote><p><img src="/JMM-img/1665475931323.png" style="zoom:100%;" /></p><blockquote><p>M：修改（Modified）</p><p>E：独享、互斥（Exclusive）</p><p>S：共享（Shared）</p><p>I：无效（Invalid）</p><p>一个cpu加载缓存行进行数据缓存-E</p></blockquote><p><img src="/JMM-img/1665326841636.png" style="zoom:100%;" /></p><blockquote><p>多个cpu加载缓存行进行数据缓存-S</p></blockquote><p><img src="/JMM-img/1665327010486.png" style="zoom:100%;" /></p><blockquote><p>其中某个cpu中缓存行的数据发生改变-M，会导致其他cpu中该缓存行的数据无效-I</p></blockquote><p><img src="/JMM-img/1665327015803.png" style="zoom:100%;" /></p><blockquote><p>修改缓存行数据后，同步到主存（M-&gt;S），其他cpu重新加载缓存行信息(I-&gt;S)</p></blockquote><p><img src="/JMM-img/1665327072979.png" style="zoom:100%;" /></p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同硬件实现内存屏障的方式不同，Java内存模型屏蔽了这种底层硬件平台的差异，由JVM来为不同的平台生成相应的机器码。 JVM中提供了四类内存屏障指令：</p><div class="table-container"><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1; LoadLoad; Load2</td><td>保证load1的读取操作在load2及后续读取操作之前执行</td></tr><tr><td>StoreStore</td><td>Store1; StoreStore; Store2</td><td>在store2及其后的写操作执行前，保证store1的写操作已刷新到主内存</td></tr><tr><td>LoadStore</td><td>Load1; LoadStore; Store2</td><td>在stroe2及其后的写操作执行前，保证load1的读操作已读取结束</td></tr><tr><td>StoreLoad</td><td>Store1; StoreLoad; Load2</td><td>保证store1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td></tr></tbody></table></div><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出线程工作内存中的数据到主存。总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。</p><span class='p green'>volatile内存语义的实现：</span><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。下图是JMM针对编译器制定的volatile重排序规则表。</p><div class="table-container"><table><thead><tr><th>第一个操作</th><th>第二个操作：普通读写</th><th>第二个操作：volatile读</th><th>第二个操作：volatile写</th></tr></thead><tbody><tr><td>普通读写</td><td>可以重排</td><td>可以重排</td><td>不可以重排</td></tr><tr><td>volatile读</td><td>不可以重排</td><td>不可以重排</td><td>不可以重排</td></tr><tr><td>volatile写</td><td>可以重排</td><td>不可以重排</td><td>不可以重排</td></tr></tbody></table></div><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举例来说，第二行最后一个单元格的意思是：在程序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。从上图可以看出：</p><ul><li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li><li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li><li>当第一个操作是volatile写，第二个操作是volatile读或写时，不能重排序。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p><blockquote><p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图</p></blockquote><p><img src="/JMM-img/1665327871082.png" style="zoom:100%;" /></p><blockquote><p>下图是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图</p></blockquote><p><img src="/JMM-img/1665327933526.png" style="zoom:100%;" /></p><hr><h1 id="synchronized-amp-Lock锁"><a href="#synchronized-amp-Lock锁" class="headerlink" title="synchronized&amp;Lock锁"></a>synchronized&amp;Lock锁</h1><blockquote><p>解决可见性、有序性和原子性</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized内置锁是一种对象锁(锁的是对象而非引用)，作用粒度是对象，可以用来实现对临界资源的同步互斥访问，该锁是可重入的。</p><span class='p red'>加锁的方式：</span><ul><li><p>1、同步实例方法，锁是当前实例对象</p></li><li><p>2、同步类方法，锁是当前类对象</p></li><li><p>3、同步代码块，锁是括号里面的对象</p></li></ul><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized是基于JVM内置锁实现，通过内部对象Monitor(监视器锁)实现，基于进入与退出Monitor对象实现方法与代码块同步，监视器锁的实现依赖底层操作系统的Mutex lock（互斥锁）实现，它是一个重量级锁性能较低。当然，JVM内置锁在1.5之后版本做了重大的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等技术来减少锁操作的开销，，内置锁的并发性能已经基本与Lock持平。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized关键字被编译成字节码后会翻译成monitorenter和monitorexit，这两条指令分别在同步块逻辑代码的起始位置与结束位置。</p><p><img src="/JMM-img/1665328319498.png" style="zoom:100%;" /></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个同步对象都有一个自己的Monitor(监视器锁)，加锁过程如下图所示：</p><p><img src="/JMM-img/1665328342272.png" style="zoom:100%;" /></p><h2 id="Monitor监视器锁"><a href="#Monitor监视器锁" class="headerlink" title="Monitor监视器锁"></a>Monitor监视器锁</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monitorenter：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><ul><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</li><li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；</li><li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monitorexit：执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monitorexit，指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p><blockquote><p>同步代码块</p></blockquote><p><img src="/JMM-img/1665328500031.png" style="zoom:100%;" /></p><p><img src="/JMM-img/1665328516909.png" style="zoom:100%;" /></p><blockquote><p>同步方法</p></blockquote><p><img src="/JMM-img/1665328545244.png" style="zoom:100%;" /></p><p><img src="/JMM-img/1665328559558.png" style="zoom:100%;" /></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从编译的结果来看，方法的同步并没有通过指令 monitorenter 和 monitorexit 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了 ACC_SYNCHRONIZED 标示符。JVM就是根据该标示符来实现方法的同步的：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p><blockquote><p><strong>两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成</strong>。<strong>两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。（jdk1.6开始进行了优化）</strong></p></blockquote><h2 id="什么是monitor？"><a href="#什么是monitor？" class="headerlink" title="什么是monitor？"></a>什么是monitor？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以把它理解为 一个同步工具，也可以描述为 一种同步机制，它通常被 描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。也就是通常说Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始地址。在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>; <span class="comment">//持锁线程</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表（ 每个等待锁的线程都会被封装成ObjectWaiter对象 ），_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时：</p><ul><li>首先会进入 _EntryList 集合，当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1；</li><li>若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒；</li><li>若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)；</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时，Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。监视器Monitor有两种同步方式：互斥与协作。多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问。</p><div class="note info flat"><p>那么有个问题来了，我们知道synchronized加锁加在对象上，对象是如何记录锁状态的呢？答案是锁状态是被记录在每个对象的对象头（Mark Word）中。 </p></div><p><img src="/JMM-img/1665329382328.png" style="zoom:100%;" /></p><h2 id="锁膨胀过程"><a href="#锁膨胀过程" class="headerlink" title="锁膨胀过程"></a>锁膨胀过程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。</strong>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是<strong>锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级</strong>。从JDK 1.6 中默认是开启偏向锁和轻量级锁的，可以通过-XX:-UseBiasedLocking来禁用偏向锁。</p><h3 id="无锁状态"><a href="#无锁状态" class="headerlink" title="无锁状态"></a>无锁状态</h3><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</p><blockquote><p>默认开启偏向锁</p><p>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</p><p>关闭偏向锁：-XX:-UseBiasedLocking</p></blockquote><p><img src="/JMM-img/1665543672291.png" style="zoom:100%;" /></p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p><blockquote><p>轻量级锁释放后，会变成无锁状态。</p></blockquote><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><blockquote><p>轻量级锁到重量级锁膨胀过程中的一个中间状态。不轻易在内核层面挂起线程。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p><p><img src="/JMM-img/1665544310192.png" style="zoom:100%;" /></p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><blockquote><p>在内核层面挂起线程，在monitor监视器对象中记录当前获取锁的线程对象，并且记录重试次数，其他等待线程也在monior对象的等待队列中进行记录保存。</p></blockquote><p><img src="/JMM-img/1665544439556.png" style="zoom:100%;" /></p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><blockquote><p>基于逃逸分析，进行synchronized锁的优化</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。锁消除的依据是逃逸分析的数据支持。</p><p>锁消除，前提是java必须运行在server模式（server模式会比client模式作更多的优化），同时必须开启逃逸分析</p><ul><li><p>-XX:+DoEscapeAnalysis 开启逃逸分析</p></li><li><p>-XX:+EliminateLocks 表示开启锁消除。</p></li></ul><h1 id="并发工具包"><a href="#并发工具包" class="headerlink" title="并发工具包"></a>并发工具包</h1><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    功能： 限流</span><br><span class="line"></span><br><span class="line">    10个人过山洞（10个线程），一次过两个。每次通过的时间2s（线程内部执行时间）</span><br><span class="line"> */</span><br><span class="line">public class Test1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">        //先创建一个信号量对象</span><br><span class="line">        Semaphore semaphore = new Semaphore(2);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                //模拟过山洞</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 获取信号，能获取，就通过，不能获取，就等待</span><br><span class="line">                    semaphore.acquire();  //如果获取到了，程序就可以向下执行；如果获取不到，程序就会阻塞在这个位置</span><br><span class="line"></span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;通过山洞,通过的时间点为: &quot; + simpleDateFormat.format(new Date()));</span><br><span class="line"></span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    //归还信号</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,(i+1)+&quot;号&quot;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    公司组织团建，坐大巴车（主线程）</span><br><span class="line">        （5个线程），5个人要求5个人都到齐之后，才一起出发</span><br><span class="line"> */</span><br><span class="line">public class Test2 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        CountDownLatch cdl = new CountDownLatch(5);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread((i+1) + &quot;号员工&quot;)&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    int time = new Random().nextInt(2000);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(500 + time);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;到达，时间为：&quot; + simpleDateFormat.format(new Date()));</span><br><span class="line"></span><br><span class="line">                    cdl.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;大巴车等待员工中.....,时间为:&quot; + simpleDateFormat.format(new Date()));</span><br><span class="line">        cdl.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;所有人都到达，出发，时间为:&quot; + simpleDateFormat.format(new Date()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    团建做闯关游戏</span><br><span class="line">        3个人一起闯关，三关，每一关要求所有人到达后，才能继续下一关</span><br><span class="line"> */</span><br><span class="line">public class Test3 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        CyclicBarrier cb = new CyclicBarrier(3);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                int time = new Random().nextInt(2000);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500 + time);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;到达第一关，时间为：&quot; + simpleDateFormat.format(new Date()));</span><br><span class="line">                    //等待其他参与人员都到达后，才继续下一关</span><br><span class="line">                    cb.await();</span><br><span class="line"></span><br><span class="line">                    //所有人都到达这个位置后，可以重置标记</span><br><span class="line">                    cb.reset();</span><br><span class="line"></span><br><span class="line">                    //开始闯第二关</span><br><span class="line">                    time = new Random().nextInt(2000);</span><br><span class="line">                    Thread.sleep(500 + time);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;到达第二关，时间为：&quot; + simpleDateFormat.format(new Date()));</span><br><span class="line">                    //等待其他参与人员都到达后，才继续下一关</span><br><span class="line">                    cb.await();</span><br><span class="line"></span><br><span class="line">                    //所有人都到达这个位置后，可以重置标记</span><br><span class="line">                    cb.reset();</span><br><span class="line"></span><br><span class="line">                    //开始闯第三关</span><br><span class="line">                    time = new Random().nextInt(2000);</span><br><span class="line">                    Thread.sleep(500 + time);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;到达第三关，时间为：&quot; + simpleDateFormat.format(new Date()));</span><br><span class="line">                    //等待其他参与人员都到达后，才继续下一关</span><br><span class="line">                    cb.await();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;所有人都到达第三关，闯关结束....&quot;);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,(i+1)+&quot;号员工&quot;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><blockquote><p>写时复制，读多写少的时候使用</p></blockquote><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><blockquote><p><strong>AbstractQueuedSynchronizer</strong>: 抽象队列同步器</p></blockquote><p><img src="/JMM-img/1665410445261.png" style="zoom:100%;" /></p><hr><h1 id="Atomic-amp-CAS"><a href="#Atomic-amp-CAS" class="headerlink" title="Atomic&amp;CAS"></a>Atomic&amp;CAS</h1><blockquote><p>针对之前多线对共享变量执行i++的操作，如果不加锁的情况下，会出现最终得到的结果比预期的结果值会少的情况，当时我们解决这个问题的方案是加锁，但是在这种场景下，采用加锁（悲观锁）方案解决，代价相对比较昂贵，此时可以利用原子类（内部使用CAS-乐观锁）解决</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicIntegerTest &#123;</span><br><span class="line">    private AtomicInteger atomicInteger = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        AtomicIntegerTest atomicIntegerTest = new AtomicIntegerTest();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(20);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    atomicIntegerTest.atomicInteger.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(20);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    atomicIntegerTest.atomicInteger.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicIntegerTest.atomicInteger.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="CAS-自旋（乐观锁）"><a href="#CAS-自旋（乐观锁）" class="headerlink" title="CAS+自旋（乐观锁）"></a>CAS+自旋（乐观锁）</h2><p><img src="/JMM-img/1665413804103.png" style="zoom:100%;" /></p><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p><img src="/JMM-img/1665414178249.png" style="zoom:100%;" /></p><blockquote><p>添加版本号解决ABA问题，通过版本号记录内存中数据的变化过程，没变化一次，版本号就递增1</p></blockquote><p><img src="/JMM-img/1665561935548.png" style="zoom:100%;" /></p><hr><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h2><ul><li>核心线程数</li><li>最大线程数</li><li>存活时间</li><li>存活时间单位</li><li>线程工厂</li><li>任务队列</li><li>拒绝策略</li></ul><p><img src="/JMM-img/1665413356942.png" style="zoom:100%;" /></p><h2 id="五大状态"><a href="#五大状态" class="headerlink" title="五大状态"></a>五大状态</h2><span class='p blue'>能接收新提交的任务，也能处理阻塞队列中的任务；</span><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</p><span class='p blue'>关闭状态，不再接收新提交的任务，但却可以继续处理阻塞队列中已保存的消息 (shutdown())</span><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</p><span class='p blue'>不接受任务，也不处理阻塞队列中的消息，会中断正在执行的任务 (shutdownNow())</span><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</p><span class='p blue'>所有的任务已终止，workerCount(有效线程数为0）；</span><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</p><span class='p blue'>在terminated()方法执行完后进入该状态(terminated())</span><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</p><p><img src="/JMM-img/1665412815441.png" style="zoom:100%;" /></p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><blockquote><p>private final class Worker extends AbstractQueuedSynchronizer implements Runnable</p><p>Worker内部封装了线程对象，为了保证线程执行任务时的并发安全，它本身是一个AQS同步器。同时也是一个Runnable，封装线程执行的任务。</p><p>Worker对象被创建后，线程池会将worker中的线程对象启动，这个线程采用while循环方式，从等待队列中获取任务进行代码执行。</p></blockquote><p><img src="/JMM-img/1665564895787.png" style="zoom:100%;" /></p><blockquote><p>任务执行失败后，会捕获异常，同时又将异常抛出，最终会执行到finally代码块中，在这个代码块中，会将这个线程停止，同时将对应的worker移除，同时判断线程池的状态是否是RUNNING或者SHUTDOWN，如果是，重新创建新的worker，处理队列中的任务。</p></blockquote><p><img src="/JMM-img/1665565175328.png" style="zoom:100%;" /></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql专项</title>
      <link href="/2023/06/04/Mysql-01/"/>
      <url>/2023/06/04/Mysql-01/</url>
      
        <content type="html"><![CDATA[<div class="note default simple"><p>mysql底层知识专项</p></div><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-06-04 [ 1.0 ]</p></div></div><div class='timeline-item-content'><p>首次发布</p></div></div></div><h1 id="存储引擎区别"><a href="#存储引擎区别" class="headerlink" title="存储引擎区别"></a>存储引擎区别</h1><span class='p blue'>MyISAM:</span><ul><li>表锁（并发弱）</li><li>不支持事务 — 无法保证关联的增删改操作安全</li><li>不支持外键约束</li></ul><span class='p blue'>InnoDB：</span><ul><li>表锁/行锁 — 支持行锁，并发强</li><li>支持事务 — 可以保证关联的增删改操作安全</li><li>支持外键约束</li></ul><blockquote><p>在查询时，事务检查和外键约束检查会带来额外开销，所以查询操作InnoDB的效率会收到影响。</p></blockquote><span class='p blue'>选择：</span><ul><li>一个表只做查询操作，选择MyISAM；如果这个表涉及到增删改操作，选择InnoDB</li><li>在我们的实际业务中基本没有表只做查询，所以对于引擎，基本就是选择默认的InnoDB</li><li>对于mysql服务系统的一些表，不提供增删改操作的话，会选择使用MyISAM}</li></ul><hr><h1 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h1><blockquote><p>索引是一种数据结构（通过某种方式，将数据组织在一起），在mysql数据库中默认选择的是B+Tree数据结构，通过索引可以提高查询数据的效率.</p></blockquote><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><h3 id="B-Tree结构"><a href="#B-Tree结构" class="headerlink" title="B-Tree结构"></a>B-Tree结构</h3><p>每个节点中包含索引列的值和整行行数据</p><p><img src="/mysql-img/1665138506429.png" style="zoom:90%;" /></p><h3 id="B-Tree结构-1"><a href="#B-Tree结构-1" class="headerlink" title="B+Tree结构"></a>B+Tree结构</h3><p>所有非叶子节点中只包含索引列的值，叶子节点中包含索引列的值和其他数据值，并且叶子节点之间使用实现双向关联。</p><p><img src="/mysql-img/1665138615982.png" style="zoom:90%;" /></p><blockquote><p>MySQL默认节点大小是16kb，采用B+Tree结构进行索引数据存储时，每个非叶子节点可以存储更多的索引列信息，那么对于相同数据量的表而言，采用B+Tree实现索引比采用B-Tree实现索引可以拥有更少的层级，在进行索引查询时，查找目标数据的io次数就相对更少一些。</p><p>另外B+Tree的叶子节点之间采用双向链表实现关联，可以非常方便实现范围查询。</p></blockquote><div class="note info flat"><p>b+tree索引，如果id列使用int类型的整数表示的话，三层索引结构能表示多少数据？？？<br>1亿数据量基本3层结构就可以表示了。 </p></div><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引:mysql所有数据的存储是直接存储在聚簇索引树上的,所以mysql说索引即数据,数据即索引。mysql数据库通过以下原则,保证一定会构建聚簇索引:</p><ul><li>通过表的主键,构建聚簇索引</li><li>如果表没有主键,会选择一列唯一约束的的列,构建聚簇索引</li><li>如果既没有主键,又没有唯一约束的列,会通过表中默认生成db_row_id列构建聚簇索引</li></ul><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>二级索引(辅助索引):这个索引树上只保存索引列的值和聚簇索引列的值,当我们查询数据时,如果通过这个树找不到我们需要的全部列,会通过聚簇索引列的值到聚簇索引上找,这个动作我们称之为”回表”</p><ul><li><span class='p blue'>普通索引</span></li><li><span class='p blue'>联合索引</span></li><li>唯一索引</li><li>外键索引</li><li>全文索引</li></ul><blockquote><p>聚簇索引和非聚簇索引关系</p></blockquote><p><img src="/mysql-img/1665139009676.png" style="zoom:90%;" /></p><h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><p>创建索引:</p><ul><li>create index 索引名 on 表名(列名1,列名2,…);</li><li>alter table 表名 add index 索引名(列名1,列名2,…);</li></ul><p>查看索引:</p><ul><li>show index from 表名;</li></ul><p>删除索引:</p><ul><li>drop index 索引名 on 表名;</li></ul><h2 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h2><p>索引的创建原则：</p><ul><li><span class='p red'>索引的创建不是一劳永逸，需要根据后期的查询需求，做对应的取舍</span><p>  ① 一张表的索引个数不允许过多，不允许超过5个</p><pre><code>第一，每一个索引都是一个B+Tree的结构，需要占用数据库的存储空间，索引过多，会给存储带来压力第二，数据在索引树上是有序的，我们对表中记录进行增删改后，需要维护每个树的数据顺序，如果树过多，会造成增删改效率降低</code></pre><p>  ② 根据查询条件，基于最左匹配原则，创建索引;最左匹配原则是适用于所有索引的，不仅限于联合索引</p><pre><code>数据在索引上是有顺序的，假设基于name和age构建一个联合索引   数据是：zs-18 , zz-25, za-60  这些数据在索引树上的顺序是：za-60,zs-18,zz-25  select * from student where name=&#39;xx&#39;;  -- 可以使用索引  select * from student where age=18;     -- 不可以使用索引  select * from student where age=18 and name=&#39;xx&#39;; -- 可以使用索引  select * from student where age=18 or name=&#39;xx&#39;  -- 不可以使用索引  select * from student where name like &#39;xx%&#39;     -- 可以使用索引  select * from student where name like &#39;%xx%&#39;    -- 不可以使用索引</code></pre><p>  ③ 索引列的值占据的空间要尽可能小，mysql每次加载一页（16kb）能包含的行记录信息会更多，我们可以通过更少的io操作来查询到我们想要的数据。实际开发中，如果就是需要按照某一列来构建索引，但是这一列的值又很大，此时我们可以利用这一列的前几个字符来构建索引 — “前缀索引”，这个前缀到底要取多少个字符，需要进行计算的。</p><pre><code>  SELECT COUNT(DISTINCT SUBSTRING(NAME,1,8))/COUNT(1) FROM product; -- 这个计算出来的值最起码大于90%  CREATE INDEX idx_name ON product(NAME(8)); -- 基于name列的前8个字符，创建前缀索引</code></pre><p>  ④ 尽可能减少回表操作，可以将需要查询的列结合查询条件，一并构建联合索引，这种操作称之为“覆盖索引”</p><pre><code>  CREATE INDEX idx_name ON product(NAME(8));  SELECT id,NAME,price FROM product WHERE NAME=&#39;BfUifcYGBE&#39;; -- 要查询price，需要回表  CREATE INDEX idx_name_price ON product(NAME(8),price);  SELECT id,NAME,price FROM product WHERE NAME=&#39;BfUifcYGBE&#39;; -- 查询的price就在索引树上，不需要回表</code></pre><p>  ⑤ where与order by冲突时优先where</p><blockquote><p>在where和order by出现索引设计冲突时，到底是针对where去设计索引，还是针对order by设计索引？到底是让where去用上索引，还是让order by用上索引?<br>  一般这种时候往往都是让where条件去使用索引来快速筛选出来一部分指定的数据，接着再进行排序。因为大多数情况基于索引进行where筛选往往可以最快速度筛选出你要的少部分数据，然后做排序的成本可能会小很多。</p></blockquote></li></ul><h2 id="索引失效常见情况"><a href="#索引失效常见情况" class="headerlink" title="索引失效常见情况"></a>索引失效常见情况</h2><pre><code>1、不要在索引列上做任何操作（计算、函数、自动/手动类型转换），会导致索引失效而全表扫描2、mysql使用不等于、not in、not exists的时候无法使用索引会导致全表扫描3、is null、is not null一般情况下也无法使用索引4、联合索引第一个字段就用范围查找不会走索引，mysql内部可能觉得第一个字段就用范围，结果集应该很大，回表效率不高，还不如直接全表扫描5、in和or在表数据比较大的情况下会走索引，表数据不多的情况下会选择全表扫描6、字符串不加单引号，导致索引失效</code></pre><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees_copy WHERE name like &#x27;LiLei%&#x27; AND age = 22 AND position =&#x27;manager&#x27;;</span><br><span class="line">MySQL5.6之前，这条语句先使用联合索引中name前缀查找符合数据，然后回表得到数据后，在比对age和position，过滤掉无效数据</span><br><span class="line">MySQL5.6开始，引入了索引下推优化，可以在索引遍历过程中，对索引中包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可以有效减少回表次数（对于innodb引擎索引下推只能用于二级索引）</span><br><span class="line">****索引下推也不是必然的，如果查找到的数据量非常大，可能也不会走索引下推，比如范围查找。</span><br></pre></td></tr></table></figure><h3 id="filesort文件排序"><a href="#filesort文件排序" class="headerlink" title="filesort文件排序"></a>filesort文件排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单路排序：一次性取出所有满足条件的字段，然后在sort buffer中进行排序</span><br><span class="line">双路排序：也叫回表排序，首先根据相应的条件取出相应的排序字段和可以直接定位行数据的ID，然后在sort buffer中进行排序，排序完成后需要再次取回其他需要的字段。</span><br><span class="line">MySQL通过比较系统变量max_length_for_sort_data(默认1024字节)的大小和需要查询的字段总大小来判断使用哪种排序模式：</span><br><span class="line">     查询某一行字段的总大小小于mlfsd，使用单路排序</span><br><span class="line">     查询某一行字段的总大小大于mlfsd，使用双路排序</span><br><span class="line">     ***可以调整mlfsd的大小，控制使用单路排序或者双路排序，但是慎重使用</span><br></pre></td></tr></table></figure><h2 id="索引设计实战"><a href="#索引设计实战" class="headerlink" title="索引设计实战"></a>索引设计实战</h2><p>以社交场景APP来举例，我们一般会去搜索一些好友，这里面就涉及到对用户信息的筛选，这里肯定就是对用户user表搜索了，这个表一般来说数据量会比较大，我们先不考虑分库分表的情况，比如，我们一般会筛选地区(省市)，性别，年龄，身高，爱好之类的，有的APP可能用户还有评分，比如用户的受欢迎程度评分，我们可能还会根据评分来排序等等。</p><p>对于后台程序来说除了过滤用户的各种条件，还需要分页之类的处理，可能会生成类似sql语句执行：</p><ul><li>select xx from user where xx=xx and xx=xx order by xx limit xx,xx</li></ul><p>对于这种情况如何合理设计索引了，比如用户可能经常会根据省市优先筛选同城的用户，还有根据性别去筛选，那我们是否应该设计一个联合索引 (province,city,sex) ？这些字段好像基数都不大，其实是应该的，因为这些字段查询太频繁了。假设又有用户根据年龄范围去筛选了，比如<span class='p green'>where province=xx and city=xx and age>=xx and age<=xx</span>，我们尝试着把age字段加入联合索引 (province,city,sex,age)，<strong>注意，一般这种范围查找的条件都要放在最后</strong>，之前讲过联合索引范围之后条件的是不能用索引的，但是对于当前这种情况依然用不到age这个索引字段，因为用户没有筛选sex字段，那怎么优化了？ </p><p>其实我们可以这么来优化下sql的写法：<span class='p blue'>where province=xx and city=xx and sex in (female</span>。对于爱好之类的字段也可以类似sex字段处理，所以可以把爱好字段也加入索引(province,city,sex,hobby,age)</p><p>假设可能还有一个筛选条件，比如要筛选最近一周登录过的用户，一般大家肯定希望跟活跃用户交友了，这样能尽快收到反馈，对应后台sql可能是这样：</p><ul><li>where province=xx and city=xx and sex in (‘female’,’male’) and age&gt;=xx and age&lt;=xx and latest_login_time&gt;= xx。</li></ul><p>那我们是否能把 latest_login_time 字段也加入索引了？比如(province,city,sex,hobby,age,latest_login_time) ，显然是不行的，那怎么来优化这种情况了？其实我们可以试着再设计一个字段is_login_in_latest_7_days，用户如果一周内有登录值就为1，否则为0，那么我们就可以把索引设计成 (province,city,sex,hobby,is_login_in_latest_7_days,age) 来满足上面那种场景了！</p><p>一般来说，通过这么一个多字段的索引是能够过滤掉绝大部分数据的，就保留小部分数据下来基于磁盘文件进行order by语句的排序，最后基于limit进行分页，那么一般性能还是比较高的。</p><p>不过有时可能用户会这么来查询，就查下受欢迎度较高的女性，比如sql：where sex = ‘female’ order by score limit xx,xx，那么上面那个索引是很难用上的，不能把太多的字段以及太多的值都用in语句拼接到sql里的，那怎么办了？其实我们可以再设计一个辅助的联合索引，比如 (sex,score)，这样就能满足查询要求了。</p><blockquote><p>以上就是给大家讲的一些索引设计的思路了，<strong>核心思想就是，尽量利用一两个复杂的多字段联合索引，抗下</strong><br><strong>你80%以上的查询，然后用一两个辅助索引尽量抗下剩余的一些非典型查询，保证这种大数据量表的查询尽</strong><br><strong>可能多的都能充分利用索引，这样就能保证你的查询速度和性能了！</strong></p></blockquote><h1 id="执行计划-explain"><a href="#执行计划-explain" class="headerlink" title="执行计划-explain"></a>执行计划-explain</h1><h2 id="id列"><a href="#id列" class="headerlink" title="id列"></a>id列</h2><p>select的序列号，有几个select就有几个id；id越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</p><h2 id="select-type列"><a href="#select-type列" class="headerlink" title="select_type列"></a>select_type列</h2><p>表示对应行是简单还是复杂查询</p><ul><li>simple-简单查询，不包含子查询和union查询</li><li>primary-复杂查询中最外层的select</li><li>subquery-包含在select中的子查询（不在from子句中）</li><li>derived-包含在from子句中的子查询。mysql会将结果存放在一个临时表中，也称为派生表（derived的含义）</li><li>union-在union中的第二个和随后的select</li></ul><h2 id="table列"><a href="#table列" class="headerlink" title="table列"></a>table列</h2><p>表示explain的一行正在访问哪个表</p><h2 id="type列"><a href="#type列" class="headerlink" title="type列"></a>type列</h2><p>表示关联类型或访问类型，即mysql决定如何查找表中的行，查找数据记录的大概范围。<br>依次优到差为：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL,一般来说，得保证查询达到range级别，最好达到ref级别</p><ul><li><strong>NULL</strong>-mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。比如：在索引中选取最小值，可以单独查询索引来完成，不需要在执行时访问表</li><li><strong>const，system</strong>-mysql能对查询的某部分进行优化并将其转化为一个常量。用于primary key或者unique key的所有列和常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system是const的特里，表示只有一条元组匹配时为system（表里只有一条数据）</li><li><strong>eq_ref</strong>:primary key或unique key索引的所有部分被连接使用，最多只会返回一条符合条件的记录。这可能是在const之外最好的连接类型了，简单的select查询不会出现这种type</li><li><strong>ref</strong>：相比eq_ref，不使用唯一索引，而是使用普通索引或者唯一索引的部分前缀，索引要和某个值比较，可能会找到多个符合条件的行</li><li><strong>range</strong>：范围扫描通常出现在in(),between,&gt;,&gt;,&gt;=等操作中，使用一个索引来检索给定范围的行</li><li><strong>index</strong>：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一点。</li><li><strong>ALL</strong>：全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化</li></ul><h2 id="possible-keys列"><a href="#possible-keys列" class="headerlink" title="possible_keys列"></a>possible_keys列</h2><p>查询可能使用哪些索引</p><h2 id="key列"><a href="#key列" class="headerlink" title="key列"></a>key列</h2><p>查询实际使用哪个索引</p><h2 id="key-len列"><a href="#key-len列" class="headerlink" title="key_len列"></a>key_len列</h2><p>显示mysql在索引中使用的字节数，通过这个值可以算出具体使用了索引中那些列</p><h2 id="ref列"><a href="#ref列" class="headerlink" title="ref列"></a>ref列</h2><p>在key列记录的索引中，表查找值所用到的列或者常量，常见的有：const-常量，字段名（如film.id）</p><h2 id="rows列"><a href="#rows列" class="headerlink" title="rows列"></a>rows列</h2><p>mysql要读取并检测的行数，不是结果集的行数</p><h2 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h2><p>这一列展示额外信息</p><ul><li><strong>Using index</strong>-使用覆盖索引</li><li><strong>Using where</strong>-使用where语句来处理结果，查询的列未被索引覆盖</li><li><strong>Using index condition</strong>-查询的列不完全被索引覆盖，where条件中是一个前导列的范围</li><li><strong>Using temporary</strong>-创建一张临时表来处理查询，出现这种情况一般是要进行优化的，首先要想到用索引来优化</li><li><strong>Using filesort</strong>-用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</li><li><strong>Select tables optimized away</strong>-使用某些聚合函数（如max、min）来访问存在索引的某个字段时</li></ul><blockquote><p><strong>重点关注 type（system|consts|eq_ref|ref|range|index|All）、key_len、extra(index|where|index condition|temporary|filesort|select tables optimized away)</strong></p></blockquote><h1 id="数据类型选择"><a href="#数据类型选择" class="headerlink" title="数据类型选择"></a>数据类型选择</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">数值类型</span><br><span class="line">      1. 如果整形数据没有负数，如ID号，建议指定为UNSIGNED无符号类型，容量可以扩大一倍。</span><br><span class="line">      2. 建议使用TINYINT代替ENUM、BITENUM、SET。</span><br><span class="line">      3. 避免使用整数的显示宽度(参看文档最后)，也就是说，不要用INT(10)类似的方法指定字段显示宽度，直接用INT。在使用zerofull时，会在显示的时候，根据显示宽度在前面补0显示</span><br><span class="line">      4. DECIMAL最适合保存准确度要求高，而且用于计算的数据，比如价格。但是在使用DECIMAL类型的时候，注意长度设置。</span><br><span class="line">      5. 建议使用整形类型来运算和存储实数，方法是，实数乘以相应的倍数后再操作。</span><br><span class="line">      6. 整数通常是最佳的数据类型，因为它速度快，并且能使用AUTO_INCREMENT。</span><br><span class="line">日期类型</span><br><span class="line">      1. MySQL能存储的最小时间粒度为秒。</span><br><span class="line">      2. 建议用DATE数据类型来保存日期。MySQL中默认的日期格式是yyyy-mm-dd。</span><br><span class="line">      3. 用MySQL的内建类型DATE、TIME、DATETIME来存储时间，而不是使用字符串。</span><br><span class="line">      4. 当数据格式为TIMESTAMP和DATETIME时，可以用CURRENT_TIMESTAMP作为默认（MySQL5.6以后），MySQL会自动返回记录插入的确切时间。</span><br><span class="line">      5. TIMESTAMP是UTC时间戳，与时区相关。</span><br><span class="line">      6. DATETIME的存储格式是一个YYYYMMDD HH:MM:SS的整数，与时区无关，你存了什么，读出来就是什么。</span><br><span class="line">      7. 除非有特殊需求，一般的公司建议使用TIMESTAMP，它比DATETIME更节约空间，但是像阿里这样的公司一般会用DATETIME，因为不用考虑TIMESTAMP将来的时间上限问题。</span><br><span class="line">      8. 有时人们把Unix的时间戳保存为整数值，但是这通常没有任何好处，这种格式处理起来不太方便，我们并不推荐它。</span><br><span class="line">字符类型</span><br><span class="line">      1. 字符串的长度相差较大用VARCHAR；字符串短，且所有值都接近一个长度用CHAR。</span><br><span class="line">      2. CHAR和VARCHAR适用于包括人名、邮政编码、电话号码和不超过255个字符长度的任意字母数字组合。那些要用来计算的数字不要用VARCHAR类型保存，因为可能会导致一些与计算相关的问题。换句话说，可能影响到计算的准确性和完整性。</span><br><span class="line">      3. 尽量少用BLOB和TEXT，如果实在要用可以考虑将BLOB和TEXT字段单独存一张表，用id关联。</span><br><span class="line">      4. BLOB系列存储二进制字符串，与字符集无关。TEXT系列存储非二进制字符串，与字符集相关。</span><br><span class="line">      5. BLOB和TEXT都不能有默认值。</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a><span class='p red'>事务隔离级别原理之MVCC</span></h1><blockquote><p>事务隔离级别：读未提交、读已提交(RC-ORACLE)、可重复读(RR - MYSQL)、串行化</p><ul><li><p>读已提交(RC-ORACLE): 在同一个事务中，能够读取到其他事务提交数据，同一个事务前后读取到的数据可能不一样</p></li><li><p>可重复读(RR - MYSQL):在同一个事务中，前后读取到的数据一样的。</p></li></ul><p>在读已提交和可重复读这两个隔离级别下，隔离性就是靠MVCC(Multi-Version Concurrency Control)机制来保证的，对一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性，避免了频繁加锁互斥，而在串行化隔离级别为了保证较高的隔离性是通过将所有操作加锁互斥来实现的。</p></blockquote><h2 id="默认字段"><a href="#默认字段" class="headerlink" title="默认字段"></a>默认字段</h2><pre><code>innoDB存储的最基本row中包含一些额外的存储信：DATA_TRX_ID、DATA_ROLL_PTR、DB_ROW_ID、DELETE BIT。    DATA_TRX_ID标记了最新更新这条行记录的transaction id，每处理一个事务，其值自动+1    DATA_ROLL_PTR 指向当前记录项的rollback segment的undo log记录，找之前版本的数据就是通过这个指针    DB_ROW_ID，当由innodb自动产生聚集索引时，聚集索引包括这个DB_ROW_ID的值，否则聚集索引中不包括这个值，这个用于索引当中    DELETE BIT位用于标识该记录是否被删除，这里的不是真正的删除数据，而是标志出来的删除，真正意义的删除是在commit的时候。</code></pre><h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>事务在开启事务后，执行第一个select操作是，会生成read view（读视图，RR只在第一次select生成，RC在每次select时生成）。读视图中记录当前正在活跃的事务id列表、最小活跃事务id、下一个还未开启的事务id。在执行查询时，遍历undo log日志链，比对undo log中事务id和read view中的事务id，决定这条记录是否对于本次查询可见，如果不可见，会沿着undo log日志链继续判断下一个事务id，找到可见即止。</p><ul><li>① 判断undo log中事务id&lt;read view中最小活跃id；如果满足，说明在当次查询之前，对应事务已经提交，可见；如果不满足，进行②</li><li>② 判断undo log中事务id&gt;=read view中还未开启的下一个事务id，如果满足，说明事务是在当次查询之后开启，不可见；如果不满足进行③</li><li>③ 判断undo log中事务id是否在活跃事务id列表中，如果在，并且不是当前事务，说明事务还未提交，不可见。如果不在，说明事务已经提交，可见（针对读已提交而言）。</li></ul><p><img src="/mysql-img/1665387282652.png" style="zoom:90%;" /></p><p><img src="/mysql-img/1665141071465.png" style="zoom:90%;" /></p><h1 id="MySQL之BufferPool"><a href="#MySQL之BufferPool" class="headerlink" title="MySQL之BufferPool"></a>MySQL之BufferPool</h1><blockquote><p>基于局部性原则，以页为单位将磁盘中的数据预加载到缓冲池中，提升后期数据访问的效率。缓冲池有大小限制，内部采用LRU算法进行数据淘汰。</p></blockquote><p><strong>预读失效</strong>：数据被加载进内存，但是从来没有使用过，返回由于lru算法，会将真正的热数据提前淘汰掉</p><ul><li>将整个缓冲池划分为头尾相连的新生代和老生代区间，数据预加载进buffer pool时，先进入老生代，如果后续有读取到对应页的数据，才会将其挪动到新生代</li></ul><p><strong>缓冲池污染：</strong>当某一个sql语句要扫描大量数据时，导致大量数据从老生代挪动到新生代，而淘汰很多数据，但是这些被大量扫描的数据只是用了一次，就不再使用</p><ul><li>加入到老生代的数据，如果被访问，不会立即挪动到新生代，而是会在老生代停留一些时间，如果再次被访问，才会挪动到新生代</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">相关参数：</span><br><span class="line">    innodb_buffer_pool_size 缓冲池大小 默认是134217728byte = 128M</span><br><span class="line">    innodb_old_blocks_pct  老生代占缓冲池大小的比例 默认是37%</span><br><span class="line">    innodb_old_blocks_time 数据在老生代停留时间 默认是1000ms</span><br></pre></td></tr></table></figure><h1 id="mysql之binlog-amp-redolog-amp-undolog"><a href="#mysql之binlog-amp-redolog-amp-undolog" class="headerlink" title="mysql之binlog&amp;redolog&amp;undolog"></a>mysql之binlog&amp;redolog&amp;undolog</h1><blockquote><p>逻辑日志：可以简单理解为记录的就是sql语句<br>物理日志：因为mysql数据最终是保存在数据页中的，物理日志记录的就是数据页变更</p></blockquote><ul><li><strong>binlog：</strong>记录数据库执行的写入行操作（不包括查询）信息，以二进制的形式保存到磁盘中。binlo是mysql的逻辑日志，并且由server层进行记录，使用任何存储引擎，都会记录binlog日志。（主从复制、数据恢复）。只有事务提交时，才会记录binlog。事务未提交时，数据在内存中，何时提交，可以配置（操作系统决定、每commit、N个事务结束后）</li><li><strong>redolog：</strong>记录事务对数据页做了哪些修改（保证持久性，事务提交，数据就会持久化，即使mysql宕机，数据依然不会丢失）。这个<strong>文件采用顺序写入，有固定大小，会循环覆盖</strong>。主要解决：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①innodb以页为单位进行磁盘交互，一个事务可能只修改几个字节，如果整个页刷新到磁盘，浪费资源，影响效率</span><br><span class="line">②一个事务可能修改多个页，这些页在物理上不是连续的，使用随机io写入性能很差</span><br><span class="line"></span><br><span class="line">*** 所有的写操作都是直接操作Buffer Pool中数据，同时将操作记录到redolog中，另外基于异步线程的方式将Buffer Pool中的数据修改更新到磁盘文件中，如果数据库宕机，磁盘文件更新还没来得及完成，会通过redolog进行数据恢复。</span><br></pre></td></tr></table></figure><blockquote><p><strong>redo log包括两部分：</strong>一个是内存中的日志缓冲(redo log buffer)，另一个是磁盘上的日志文件(redo log file)。mysql每执行一条DML语句，先将记录写入redo log buffer，后续某个时间点再一次性将多个操作记录写到redo log file。这种先写日志，再写磁盘的技术就是MySQL里经常说到的<strong>WAL</strong>(Write-Ahead Logging) 技术。</p><p>内存缓存数据到磁盘文件过程：log buffer—》os buffer—》log file</p></blockquote><ul><li><strong>undolog：</strong>回滚日志，保证原子性操作，同时也是MVCC实现的关键<blockquote><p>insert对应一条delete操作<br>update对应一条反向的update操作<br>delete对应一个delete标记</p></blockquote></li></ul><p><img src="/mysql-img/1665144202896.png" style="zoom:90%;" /></p><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p><img src="/mysql-img/1665453064648.png" style="zoom:90%;" /></p><h2 id="常见方案"><a href="#常见方案" class="headerlink" title="常见方案"></a>常见方案</h2><p><img src="/mysql-img/1665146153202.png" style="zoom:90%;" /></p><h2 id="2PC（两阶段提交）方案"><a href="#2PC（两阶段提交）方案" class="headerlink" title="2PC（两阶段提交）方案"></a>2PC（两阶段提交）方案</h2><p>两阶段提交协议（Two Phase Commit）不是在XA规范中提出，但是XA规范对其进行了优化。而从字面意思来理解，Two Phase Commit，就是将提交(commit)过程划分为2个阶段(Phase)：</p><p><strong>阶段1：</strong></p><ul><li>TM通知各个RM准备提交它们的事务分支。如果RM判断自己进行的工作可以被提交，那就对工作内容进行持久化，再给TM肯定答复；要是发生了其他情况，那给TM的都是否定答复。在发送了否定答复并回滚了已经的工作后，RM就可以丢弃这个事务分支信息。</li><li>以mysql数据库为例，在第一阶段，事务管理器向所有涉及到的数据库服务器发出prepare”准备提交”请求，数据库收到请求后执行数据修改和日志记录等处理，处理完成后只是把事务的状态改成”可以提交”,然后把结果返回给事务管理器。</li></ul><p><strong>阶段2</strong></p><ul><li>TM根据阶段1各个RM prepare的结果，决定是提交还是回滚事务。如果所有的RM都prepare成功，那么TM通知所有的RM进行提交；如果有RM prepare失败的话，则TM通知所有RM回滚自己的事务分支。</li><li>以mysql数据库为例，如果第一阶段中所有数据库都prepare成功，那么事务管理器向数据库服务器发出”确认提交”请求，数据库服务器把事务的”可以提交”状态改为”提交完成”状态，然后返回应答。如果在第一阶段内有任何一个数据库的操作发生了错误，或者事务管理器收不到某个数据库的回应，则认为事务失败，回撤所有数据库的事务。数据库服务器收不到第二阶段的确认提交请求，也会把”可以提交”的事务回撤。</li></ul><p><img src="/mysql-img/1665146392477.png" style="zoom:90%;" /></p><p><strong>两阶段提交协议(2PC)存在的问题</strong></p><p>二阶段提交看起来确实能够提供原子性的操作，但是不幸的是，二阶段提交还是有几个缺点的：</p><ul><li><p><strong>1、同步阻塞问题。</strong><br>两阶段提交方案下全局事务的ACID特性，是依赖于RM的。一个全局事务内部包含了多个独立的事务分支，这一组事务分支要不都成功，要不都失败。各个事务分支的ACID特性共同构成了全局事务的ACID特性。也就是将单个事务分支的支持的ACID特性提升一个层次到分布式事务的范畴。 即使在本地事务中，如果对操作读很敏感，我们也需要将事务隔离级别设置为SERIALIZABLE。而对于分布式事务来说，更是如此，可重复读隔离级别不足以保证分布式事务一致性。如果我们使用mysql来支持XA分布式事务的话，那么最好将事务隔离级别设置为SERIALIZABLE，然而SERIALIZABLE(串行化)是四个事务隔离级别中最高的一个级别，也是执行效率最低的一个级别。</p></li><li><p><strong>2、单点故障。</strong><br>由于协调者的重要性，一旦协调者TM发生故障，参与者RM会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p></li><li><p><strong>3、数据不一致。</strong><br>在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这会导致只有一部分参与者接受到了commit请求，而在这部分参与者接到commit请求之后就会执行commit操作，但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。</p></li></ul><p><img src="/mysql-img/1665455319708.png" style="zoom:90%;" /></p><h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><p><img src="/mysql-img/1665149765508.png" style="zoom:90%;" /></p><p><strong>在阶段1：</strong></p><ul><li>在XA中，各个RM准备提交各自的事务分支，事实上就是准备提交资源的更新操作(insert、delete、update等)；而在TCC中，是主业务活动请求(try)各个从业务服务预留资源。</li></ul><p><strong>在阶段2：</strong></p><ul><li>XA根据第一阶段每个RM是否都prepare成功，判断是要提交还是回滚。如果都prepare成功，那么就commit每个事务分支，反之则rollback每个事务分支。</li><li>TCC中，如果在第一阶段所有业务资源都预留成功，那么confirm各个从业务服务，否则取消(cancel)所有从业务服务的资源预留请求。</li></ul><p><strong>TCC两阶段提交与XA两阶段提交的区别是：</strong></p><ul><li><span class='p blue'>XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。</span></li><li><span class='p blue'>TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。</span></li></ul><p><strong>TCC事务的优缺点：</strong></p><ul><li><p><strong>优点：</strong>XA两阶段提交资源层面的，而TCC实际上把资源层面二阶段提交上提到了业务层面来实现。有效了的避免了XA两阶段提交占用资源锁时间过长导致的性能地下问题。<br>相对于 AT 模式，TCC 模式对业务代码有一定的侵入性，但是 TCC 模式无 AT 模式的全局行锁，TCC 性能会比 AT 模式高很多。</p></li><li><p><strong>缺点：</strong>主业务服务和从业务服务都需要进行改造，从业务方改造成本更高。原来只需要提供一个接口，现在需要改造成try、confirm、canel 3个接口，开发成本高。</p></li></ul><h3 id="空回滚"><a href="#空回滚" class="headerlink" title="空回滚"></a>空回滚</h3><p>空回滚：在没有调用 TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel 方法，Cancel 方法需要识别出这是一个空回滚，然后直接返回成功。</p><p>空回滚出现的原因:  Try超时（丢包），分布式事务回滚触发Cancel，出现未收到Try，收到Cancel的情况</p><p><img src="/mysql-img/1665150476612.png" style="zoom:90%;" /></p><h3 id="悬挂"><a href="#悬挂" class="headerlink" title="悬挂"></a>悬挂</h3><p>悬挂：Cancel比Try先执行</p><p>悬挂出现的原因：Try超时（拥堵），分布式事务回滚触发Cancel，之后拥堵的Try到达</p><p><img src="/mysql-img/1665150539746.png" style="zoom:90%;" /></p><h3 id="幂等控制"><a href="#幂等控制" class="headerlink" title="幂等控制"></a>幂等控制</h3><p>因为网络抖动或拥堵可能会超时，事务管理器会对资源进行重试操作，所以很可能一个业务操作会被重复调用，为了不因为重复调用而多次占用资源，需要对服务设计时进行幂等控制，通常我们可以用事务 xid 或业务主键判重来控制。</p><p><img src="/mysql-img/1665150607149.png" style="zoom:90%;" /></p><p><img src="/mysql-img/1665456811040.png" style="zoom:90%;" /></p><h3 id="案例设计"><a href="#案例设计" class="headerlink" title="案例设计"></a>案例设计</h3><p><img src="/mysql-img/1665150747845.png" style="zoom:90%;" /></p><h2 id="可靠消息最终一致性"><a href="#可靠消息最终一致性" class="headerlink" title="可靠消息最终一致性"></a>可靠消息最终一致性</h2><p>方案一：mq+消息日志表 OR 参照订单业务</p><p><img src="/mysql-img/1665458438794.png" style="zoom:90%;" /></p><blockquote><p>我们自己通过消息日志表，确认另一方事务是否成功</p></blockquote><p>方案二：rocketmq事务消息</p><blockquote><p>由rocketmq本身确保自身事务是否成功</p></blockquote><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><blockquote><p>上述都是关于分布式事务的理论知识，实际开发中，实现分布式事务可以利用案例的seata完成</p><p>seata提供了AT、TCC、Saga、XA四种不同的分布式处理方式。</p></blockquote><p>一个典型的 Saga 案例是在线订单的处理过程。假设一个在线商店接收到一个新的订单，该订单需要进行一系列复杂的操作，包括扣款、库存扣减、发货等。如果一个事务中包含了所有这些操作，而其中任何一个操作出现错误，整个事务都必须回滚，这样就会导致整个订单处理失败，给客户带来不良体验。在这种情况下，使用 Saga 分布式事务可以大大降低出错的可能性。</p><p>在 Saga 分布式事务中，可以将订单处理拆分为多个子事务（如扣款、库存扣减、发货等）。每个子事务都是独立的事件，由不同的服务处理，并将事件状态写入数据库中。如果有任何一个子事件处理失败，则 Saga 将自动回滚整个订单的处理流程。这样每个子事件的失败对整个订单处理的影响也就被限制在了最小范围内。</p><p>举一个具体的实际案例，Spring Cloud 和 Seata 实现的订单系统就是一个使用 Saga 分布式事务的典型案例。该系统使用 Seata 编写了订单扣减服务、库存服务和物流服务，每个服务都是独立的单元，对应业务场景中的一个子事务。当有新订单时，订单扣减服务会发送一条扣款事件，库存服务会接收该事件并进行库存扣减处理，处理成功后返回结果。物流服务也会接收该事件并进行发货处理，处理成功后返回结果。如果有任何一个服务处理失败，Seata 将自动回滚整个订单的处理流程。这个案例表明，使用 Saga 分布式事务可以将一个复杂的业务场景分解为多个子事务，并在整个处理过程中协调和管理各个子事务的执行状态，大大提高了系统的健壮性和可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> myql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言简介</title>
      <link href="/2023/06/03/C-01/"/>
      <url>/2023/06/03/C-01/</url>
      
        <content type="html"><![CDATA[<div class="note default simple"><p>C语言</p></div><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-06-03 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">1.5 -&gt; 2.0</a></p></div></div><div class='timeline-item-content'><ol><li>相比1.5版本,排版更加好看</li><li>2.0 版本删除不必要的字段,内容简洁易懂</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-06-03 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">1.0 -&gt; 1.5</a></p></div></div><div class='timeline-item-content'><p>首次发布</p></div></div></div><p>The C Programming Language (sometimes termed K&amp;R, after its authors’ initials) is a computer programming book written by Brian Kernighan and Dennis Ritchie, the latter of whom originally designed and implemented the C programming language, as well as co-designed the Unix operating system with which development of the language was closely intertwined. The book was central to the development and popularization of C and is still widely read and used today. Because the book was co-authored by the original language designer, and because the first edition of the book served for many years as the de facto standard for the language, the book was regarded by many to be the authoritative reference on C.<br>C was created by Dennis Ritchie at Bell Labs in the early 1970s as an augmented version of Ken Thompson’s B. Another Bell Labs employee, Brian Kernighan, had written the first C tutorial, and he persuaded Ritchie to coauthor a book on the language. Kernighan would write most of the book’s “expository” material, and Ritchie’s reference manual became its appendices.</p><p>The first edition, published February 22, 1978, was the first widely available book on the C programming language. Its version of C is sometimes termed K&amp;R C (after the book’s authors), often to distinguish this early version from the later version of C standardized as ANSI C.</p><p>In April 1988, the second edition of the book was published, updated to cover the changes to the language resulting from the then-new ANSI C standard, particularly with the inclusion of reference material on standard libraries. The second edition of the book (and as of 2022, the most recent) has since been translated into over 20 languages. In 2012, an eBook version of the second edition was published in ePub, Mobi, and PDF formats.</p><p>ANSI C, first standardized in 1989 (as ANSI X3.159-1989), has since undergone several revisions, the most recent of which is ISO/IEC 9899:2018 (also termed C17 or C18), adopted as an ANSI standard in June 2018. However, no new edition of The C Programming Language has been issued to cover the more recent standards.</p><div align=center class="aspect-ratio">    <iframe src="https://player.bilibili.com/player.html?aid=BV1Vm4y1r7jY&&page=1&as_wide=1&high_quality=1&danmaku=0"     scrolling="no"     border="0"     frameborder="no"     framespacing="0"     high_quality=1    danmaku=1     allowfullscreen="true">     </iframe></div>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C-introduction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言简介</title>
      <link href="/2023/06/03/CPP-01/"/>
      <url>/2023/06/03/CPP-01/</url>
      
        <content type="html"><![CDATA[<p>C++ (/ˈsiː plʌs plʌs/, pronounced “C plus plus”) is a high-level, general-purpose programming language created by Danish computer scientist Bjarne Stroustrup. First released in 1985 as an extension of the C programming language, it has since expanded significantly over time; modern C++ currently has object-oriented, generic, and functional features, in addition to facilities for low-level memory manipulation. It is almost always implemented as a compiled language, and many vendors provide C++ compilers, including the Free Software Foundation, LLVM, Microsoft, Intel, Embarcadero, Oracle, and IBM.</p><p>C++ was designed with systems programming and embedded, resource-constrained software and large systems in mind, with performance, efficiency, and flexibility of use as its design highlights. C++ has also been found useful in many other contexts, with key strengths being software infrastructure and resource-constrained applications, including desktop applications, video games, servers (e.g. e-commerce, web search, or databases), and performance-critical applications (e.g. telephone switches or space probes).</p><p>C++ is standardized by the International Organization for Standardization (ISO), with the latest standard version ratified and published by ISO in December 2020 as ISO/IEC 14882:2020 (informally known as C++20). The C++ programming language was initially standardized in 1998 as ISO/IEC 14882:1998, which was then amended by the C++03, C++11, C++14, and C++17 standards. The current C++20 standard supersedes these with new features and an enlarged standard library. Before the initial standardization in 1998, C++ was developed by Stroustrup at Bell Labs since 1979 as an extension of the C language; he wanted an efficient and flexible language similar to C that also provided high-level features for program organization. Since 2012, C++ has been on a three-year release schedule with C++23 as the next planned standard.</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM专项-第一篇</title>
      <link href="/2023/06/03/JVM-01/"/>
      <url>/2023/06/03/JVM-01/</url>
      
        <content type="html"><![CDATA[<div class="note default simple"><p>JAVA虚拟机专项</p></div><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-06-03 [ 1.0 ]</p></div></div><div class='timeline-item-content'><p>首次发布</p></div></div></div><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>loadClass的类加载过程：<span class='p blue'>加载</span> &gt;&gt; <span class='p blue'>验证</span> &gt;&gt; <span class='p blue'>准备</span> &gt;&gt; <span class='p blue'>解析</span> &gt;&gt; <span class='p blue'>初始化</span> &gt;&gt; <span class='p blue'>使用</span> &gt;&gt; <span class='p blue'>卸载</span></p><ul><li><span class='p blue'>加载：</span>在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的 main()方法，new对象等等，在加载阶段会在内存（堆）中生成一个代表这个类的 java.lang.Class对象，在方法区中，其就作为这个类的各种数据的访问渠道</li><li><span class='p blue'>验证：</span>校验字节码文件的正确性</li><li><span class='p blue'>准备：</span>在方法区，给类的静态变量分配内存，并赋予默认值（例如int的默认值为0）</li><li><span class='p blue'>解析：</span>将静态变量的标识名替换为所指地址的引用，该阶段会把一些静态方法(符号引用即静态方法名，比如main()方法，替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用（非静态成员）</li><li><span class='p blue'>初始化：</span>对类的静态变量初始化为指定的值，执行静态代码块</li></ul><blockquote><span class='p left green'>补充=></span><ul><li><strong>类被加载到方法区中后主要包含：</strong><p class='p left'>运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用等信息</p></li><li><strong>类加载器的引用：</strong><p class='p left'>这个类到类加载器实例的引用</p></li><li><strong>对应class实例的引用：</strong><p class='p left'>类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的对象实例放到堆(Heap)中</p></li><li><p class='p left'>主类在运行过程中若引用其它类，会逐步加载这些类。jar或war包里的类不是一次性全部加载，是使用到时才加载</p></li></ul></blockquote><hr><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><div class="note info simple"><p>不同的类，由不同的类加载器加载，那么类加载器如何识别他们要加载的类呢？</p></div><p><img src="/blog-img/1664935417961.png" style="zoom:80%;" /></p><ul><li>加载任何一个类时，会首先由<span class='p blue'>应用程序类加载器</span>接收，然后委托给它的父类-<span class='p blue'>扩展类加载器</span>，扩展类加载器又委托给它的父类-<span class='p blue'>引导类加载器</span></li><li><span class='p blue'>引导类加载器</span>也不会直接加载类，而是检查此类是否是自己的管辖范围内，是则加载，否则依次向下（向其子类）委托，当最底层子类的管辖范围也不包括子类时，则报类找不到异常</li><li><p>类是由哪个类加载器负责，主要看包名。如果伪造一个系统自带的类(即类名相同)，默认由<span class='p blue'>引导类加载器</span>加载该类，虽然我们写的时候希望是由<span class='p blue'>应用程序类加载器</span>加载</p></li><li><span class='p red'>双亲委派优点：</span><p><strong>1.沙箱安全，保护系统类不被篡改</strong><br><strong>2.防止重复加载，保障类只加载一次</strong></p></li></ul><blockquote><p>可以通过自定义类加载器，实现自己的加载逻辑，从而打破双亲委派机制</p></blockquote><hr><h1 id="JVM整体结构-amp-内存模型"><a href="#JVM整体结构-amp-内存模型" class="headerlink" title="JVM整体结构&amp;内存模型"></a>JVM整体结构&amp;内存模型</h1><p><img src="/blog-img/1664942443945.png" style="zoom:85%;" /></p><ul><li>运行时数据区中包含五个内容，分别是：<span class='p blue'>堆</span>、<span class='p blue'>方法区</span>、<span class='p blue'>栈</span>、<span class='p blue'>本地方法栈</span>、<span class='p blue'>程序计数器</span>。其中后面三个是每个线程各自独带一份，而堆和方法区是所有线程共享的，由此会有线程并发安全问题，但是栈、本地方法栈和程序计数器没有线程并发安全问题。</li><li>栈帧中的方法出口，其实是一种记录，记录自己从哪来，把数据返回给谁。</li><li>栈帧中的局部变量表中，第一个局部变量就是此方法的<span class='p red'>this</span>（永远占据第一个局部变量位置），然后再是自定义的变量</li></ul><blockquote><p>每一个栈帧都包含<span class='p blue'>局部变量表</span>、<span class='p blue'>操作数栈</span>、<span class='p blue'>动态链接</span>、<span class='p blue'>方法出口</span></p></blockquote><hr><h1 id="堆区（heap）"><a href="#堆区（heap）" class="headerlink" title="堆区（heap）"></a>堆区（heap）</h1><p><img src="/blog-img/heap-01.jpg" style="zoom:80%;" /><br><strong>堆区结构：</strong></p><ul><li>堆区分为年轻代与老年代，它们的内存比例是1:2。</li><li>年轻代又分为Eden和两个幸存区，比例为8:2。两个幸存区同一时间只允许一个发生作用</li></ul><span class='p blue'>第一种进入老年代的方式：</span><ul><li>现在假设内存比例是800:200，对象创建时是在Eden区，若创建的对象内存是805，超过了Eden区的范围，此时会触发minor GC垃圾回收，假如750被回收掉，剩下的50会进入幸存区，Eden区的750直接清空</li><li>下一次创建对象内存为800，再一次触发minor GC，假设这次Eden区中被回收掉780，剩下20。原先留在幸存区的50也会触发minor GC，50中有30被回收，20 + 20 = 40，这40就会放入另一个幸存区</li><li>以此类推，每一次触发minor GC就记录一次年龄，年龄达到15，直接放到老年代。当年轻代的对象源源不断创建，持续向老年代放入内存，老年代达到内存上限，则触发full GC。full GC的回收效率很低，后续优化都是在年轻代中尽可能释放没用的资源，减少full GC次数</li></ul><span class='p blue'>第二种进入老年代的方式：</span><ul><li>可以设置多少内存为大对象，若创建的对象判断为大对象，直接放进老年代</li></ul><span class='p blue'>第三种进入老年代的方式：</span><ul><li>若Eden区回收内容后剩下的内存，比幸存区的内容的50%还大，则触发动态年龄判断机制，直接放入老年代</li></ul><blockquote><p>以上三种方式都会增加老年代的内存占据，若老年代full GC后的内容容量，满足不了年轻代源源不断注入，则会产生OMM (堆溢出)</p></blockquote><hr><h1 id="JVM内存参数设置"><a href="#JVM内存参数设置" class="headerlink" title="JVM内存参数设置"></a>JVM内存参数设置</h1><p><img src="/blog-img/1664942783352.png" style="zoom:100%;" /><br>Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐jar microservice‐eureka‐server.jar</span><br></pre></td></tr></table></figure><p>关于元空间的JVM参数有两个：</p><ul><li>-XX:MetaspaceSize=N</li><li>-XX:MaxMetaspaceSize=N</li></ul><p><strong>-XX：MaxMetaspaceSize</strong>： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小<br><strong>-XX：MetaspaceSize</strong>： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下，适当提高该值。与早期jdk版本的-XX:PermSize参数意思不一样，<strong>-XX:PermSize</strong>代表永久代的初始容量。<strong>由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，对于8G物理内存的机器来说，一般我会将这两个值都设置为256M</strong></p><hr><h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p><img src="/blog-img/1665035468422.png" style="zoom:90%;" /> </p><h2 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1.类加载检查"></a><strong>1.类加载检查</strong></h2><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><blockquote><p>new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。</p></blockquote><h2 id="2-分配内存"><a href="#2-分配内存" class="headerlink" title="2.分配内存"></a><strong>2.分配内存</strong></h2><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类 加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。<strong>这个步骤有两个问题：</strong></p><ul><li><strong>1.如何划分内存。</strong></li><li><strong>2.在并发情况下</strong>， 可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</li></ul><p><strong><span class='p blue'>划分内存的方法：</span></strong></p><ul><li><strong>1.“指针碰撞”</strong>（Bump the Pointer）(默认用指针碰撞)，如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</li><li><strong>2.“空闲列表”</strong>（Free List）如果Java堆中的内存并不是规整的，已使用的内存和空 闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记 录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li></ul><blockquote><p>堆是所有线程共享的，众多线程在分配内存时，肯定会存在并发安全问题，以上两种方式都会产生这种问题</p></blockquote><p><strong><span class='p blue'>解决并发问题的方法：</span></strong></p><ul><li><strong>1.CAS</strong>（compare and swap）虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。</li><li><strong>2.本地线程分配缓冲</strong>（Thread Local Allocation Buffer,TLAB）把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过­XX:+/­UseTLAB参数来设定虚拟机是否使用TLAB(JVM会默认开启­XX:+UseTLAB)，­XX:TLABSize 指定TLAB大小。</li></ul><blockquote><p>本地线程分配缓冲缺陷：倘若预留的内存，没有线程来占用，那么就会存在内存浪费问题</p></blockquote><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h2><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h2 id=""><a href="#" class="headerlink" title=""></a><span class='p red'>4.设置对象头</span></h2><p>初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding）（对齐方式是内存不足为8的倍数，则补齐）。 HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、==GC分代年龄、锁状态标志==、线程持有的锁、偏向线程ID、偏向时 间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><ul><li><p>32位对象头<br><img src="/blog-img/1665035851177.png" style="zoom:100%;" /><br><img src="/blog-img/1665035887873.png" style="zoom:100%;" /></p></li><li><p>64位对象头<br><img src="/blog-img/1665037961482.png" style="zoom:100%;" /></p></li></ul><h2 id="5-执行方法"><a href="#5-执行方法" class="headerlink" title="5.执行方法"></a>5.执行方法</h2><p>执行方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。</p><hr><h1 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a>指针压缩</h1><p><strong>什么是java对象的指针压缩？</strong></p><ul><li>1.jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩</li><li>2.jvm配置参数:UseCompressedOops，compressed­­压缩、oop(ordinary object pointer)­­对象指针</li><li>3.启用指针压缩:­XX:+UseCompressedOops(默认开启)，禁止指针压缩:­XX:­UseCompressedOops</li></ul><p><strong>为什么要进行指针压缩？</strong></p><ul><li>1.在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，占用较大宽带，同时GC也会承受较大压力</li><li>2.为了减少64位平台下内存的消耗，启用指针压缩功能</li><li>3.在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)</li><li>4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间</li><li>5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java简介</title>
      <link href="/2023/06/03/Java-01/"/>
      <url>/2023/06/03/Java-01/</url>
      
        <content type="html"><![CDATA[<p>Java is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is a general-purpose programming language intended to let programmers write once, run anywhere (WORA), meaning that compiled Java code can run on all platforms that support Java without the need to recompile. Java applications are typically compiled to bytecode that can run on any Java virtual machine (JVM) regardless of the underlying computer architecture. The syntax of Java is similar to C and C++, but has fewer low-level facilities than either of them. The Java runtime provides dynamic capabilities (such as reflection and runtime code modification) that are typically not available in traditional compiled languages. As of 2019, Java was one of the most popular programming languages in use according to GitHub,[citation not found] particularly for client–server web applications, with a reported 9 million developers.</p><p>Java was originally developed by James Gosling at Sun Microsystems. It was released in May 1995 as a core component of Sun Microsystems’ Java platform. The original and reference implementation Java compilers, virtual machines, and class libraries were originally released by Sun under proprietary licenses. As of May 2007, in compliance with the specifications of the Java Community Process, Sun had relicensed most of its Java technologies under the GPL-2.0-only license. Oracle offers its own HotSpot Java Virtual Machine, however the official reference implementation is the OpenJDK JVM which is free open-source software and used by most developers and is the default JVM for almost all Linux distributions.</p><p>As of March 2023, Java 20 is the latest version, while Java 17, 11 and 8 are the current long-term support (LTS) versions.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理简介</title>
      <link href="/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-01/"/>
      <url>/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-01/</url>
      
        <content type="html"><![CDATA[<p>计算机系统是当代生活中比较常见的复杂系统之一。随着科技的发展，计算机系统正变得愈加成熟。</p><p>究其本质，计算机系统由硬件和软件两大部分组成。硬件的工作依靠软件的控制，软件的运行依托硬件的支持。两者相互依存，不可分割。</p><p>硬件指的是计算机的实体部分，也就是“看得见，摸得着”的部分，由各类电子元器件以及光、电、机等相关设备组成，包括主机和外设等。</p><p>现在最常见的计算机系统，是1945年编制的冯·诺依曼计算机。我们日常所指的计算机，基本都是冯·诺依曼计算机。读本所介绍的，也是冯·诺依曼计算机。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络简介</title>
      <link href="/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-01/"/>
      <url>/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-01/</url>
      
        <content type="html"><![CDATA[<p>计算机网络（英语：computer network），通常也简称网络，是指容许节点分享资源的数字电信网络:1-3。在电脑网络，电脑设备会透过节点之间的连接（数据链路）互相交换数据，即收发（接收和发放）网络信息。传输介质可分为有线及无线两类——有线的可用到双绞线、光纤电缆等介质；无线则可用到Wi-Fi、NFC和Bluetooth等。</p><p>用于创建、路由及终止数据传输的电脑网络设备即为网络节点。节点包括像个人电脑、电话、服务器般的主机及其他网络硬件（如网关及路由器）。它们一般以网络地址作标识符。当一个设备能够与另一设备交换信息时，便可视它们俩已连接成网络，不论它们是否直连。专用通信协议在大多数分层中位于其他更通用的通信协议之上。要维持网络的可靠性，便需要有一定的网络管理技能。</p><p>电脑网络为海量应用程序及服务背后的基础。比如存取互联网、数字视频、数字音频；共享打印机；收发电子邮件及即时通信消息:4-p.21-29。电脑网络可依照传输介质、传输协议、 网络大小、拓扑、流量控制机制、创建目的等因素区分。世界上最大的电脑网络为互联网。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/06/02/2023-6-2-firstpage/"/>
      <url>/2023/06/02/2023-6-2-firstpage/</url>
      
        <content type="html"><![CDATA[<ul><li>初次搭建博客<br>有很多不完善的地方，还行持续改善</li><li>个人Github账号名称<span class='p center logo large'>Ginkgovio</span><span class='p center small'>A Wonderful Name</span></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>照片墙</title>
      <link href="/Gallery/index.html"/>
      <url>/Gallery/index.html</url>
      
        <content type="html"><![CDATA[<span class='p center logo large'>Pixiv</span><span class='p center small'>A Wonderful Image for Top50</span><div align="center"><iframe src="https://pixiv.mokeyjay.com" style="width:240px; height:380px; border: 0"></iframe></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>bilibili</title>
      <link href="/bangumis/index.html"/>
      <url>/bangumis/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<!-- GitCalendar容器 --><div id="gitZone"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>书架</title>
      <link href="/bookshelf/index.html"/>
      <url>/bookshelf/index.html</url>
      
        <content type="html"><![CDATA[<div class="site-card-group"><a class="site-card" href="https://www.99csw.com/book/9694/index.htm"><div class="img"><img src="https://img2.baidu.com/it/u=3539402939,2357114515&fm=253&fmt=auto&app=138&f=JPEG?w=350&h=350"/></div><div class="info"><span class="title">你一生的故事</span><span class="desc">特德·姜早期的七篇代表作品</span></div></a><a class="site-card" href="https://www.tianyabooks.com/book/Wells_01/"><div class="img"><img src="https://upload.wikimedia.org/wikipedia/zh/8/8e/The_War_of_the_Worlds_%28novel%29.png"/></div><div class="info"><span class="title">世界大战</span><span class="desc">随着一颗陨石降落到地球，火星人正式造访了地球...</span></div></a><a class="site-card" href="https://read.douban.com/reader/ebook/8283139/"><div class="img"><img src="https://pic.arkread.com/cover/ebook/f/46318144.1653703337.jpg!cover_default.jpg"/></div><div class="info"><span class="title">时间机器</span><span class="desc">一位科学家通过时间旅行机器来到公元802701年。这时的地球到处是宫殿式建筑...</span></div></a><a class="site-card" href="https://read.douban.com/reader/ebook/108264372/"><div class="img"><img src="https://images-cn.ssl-images-amazon.com/images/I/71+GMO6Nt+L._AC_UL600_SR600,600_.jpg"/></div><div class="info"><span class="title">隐身人</span><span class="desc">求知欲和权力欲一旦凌驾于良知之上，将会造成无法挽回的悲剧</span></div></a></div><hr><div class="site-card-group"><a class="site-card" href="https://read.douban.com/reader/ebook/7965034/"><div class="img"><img src="https://img1.baidu.com/it/u=110883726,1109222699&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=666"/></div><div class="info"><span class="title">永恒的终结</span><span class="desc">人类在掌握时间旅行技术后，成立了一个叫做永恒时空（Eternity）的组织，在每个时代的背后，默默地守护着人类社会的发展</span></div></a><a class="site-card" href="https://read.douban.com/reader/ebook/332115752/"><div class="img"><img src="https://bookcover.yuewen.com/qdbimg/349573/1029907008/300.webp"/></div><div class="info"><span class="title">菲利普·迪克传</span><span class="desc">菲利普·迪克-“科幻小说界的梵高”</span></div></a><a class="site-card" href="https://read.douban.com/reader/ebook/122825227/"><div class="img"><img src="https://image.gcores.com/da6828e7-6215-4138-a18f-4ed73bcd6434.jpg?x-oss-process=image/quality,q_90/format,webp"/></div><div class="info"><span class="title">龙蛋</span><span class="desc">一种相对稳定的自我复制的现象在自然界中并不稀罕，而生物的诞生却要求了多得多的条件</span></div></a><a class="site-card" href="https://www.dedao.cn/ebook/detail?id=lxaVvndNG6D4kgLJ2OKxqVMmE1zXPwVpXdWAdjyQeYR75vbaBnr9ol8pZERLg1my&source=douban"><div class="img"><img src="http://t15.baidu.com/it/u=2129360457,1064932732&fm=224&app=112&f=JPEG?w=344&h=499"/></div><div class="info"><span class="title">盲视</span><span class="desc">求知欲和权力欲一旦凌驾于良知之上，将会造成无法挽回的悲剧</span></div></a></div><hr><div class="site-card-group"><a class="site-card" href="https://www.99csw.com/book/1691/index.htm"><div class="img"><img src="https://img.zcool.cn/community/01e67d5dca6d93a801209e1f4203fb.jpg@1280w_1l_2o_100sh.jpg"/></div><div class="info"><span class="title">献给阿尔吉侬的花束</span><span class="desc">学习是件很奇怪的事，走得越远，越知道自己连知识存在何处都不清楚</span></div></a><a class="site-card" href="https://cread.jd.com/read/startRead.action?bookId=30733051&readType=1"><div class="img"><img src="https://images-cn.ssl-images-amazon.cn/images/I/51lSj1Vk23L.jpg"/></div><div class="info"><span class="title">惨败</span><span class="desc">出版于1987年，是莱姆一生创作中的最后一部虚构类文学作品，也是他篇幅最长的科幻小说</span></div></a><a class="site-card" href="https://zhiqiang.org/resource/while-appreciation-for-life.html"><div class="img"><img src="https://img3m6.ddimg.cn/34/30/21097726-2_e_2.jpg"/></div><div class="info"><span class="title">趁生命气息逗留</span><span class="desc">人类并没有改变。他们时而神志清醒，时而丧失理智...</span></div></a><a class="site-card" href="https://zh.anarchistlibraries.net/library/e-xiu-la-le-gu-en-yi-wu-suo-you#toc3"><div class="img"><img src="https://www.kfzimg.com/G06/M00/B2/41/p4YBAFrS97SABRbQAAEH1ZWMDXU339_b.jpg"/></div><div class="info"><span class="title">一无所有</span><span class="desc">社会的约束虽然实现了对全体成员的保障，却渐渐成为一种禁锢。</span></div></a></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[:root {    --trans-light: rgba(255, 255, 255, 0.95);    --trans-dark: rgba(25, 25, 25, 0.95);    --border-style: 1px solid rgb(169, 169, 169);    --backdrop-filter: none; /* blur(5px) saturate(150%); 耗性能一般不开*/}/* 页脚与头图透明 */#footer {    background: transparent !important;}#page-header {    background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {    background: transparent !important;}#page-header::before {    background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}/* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {    background: #1e1e1e;    color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {    background: #3ecdf1;    color: #f2f2f2;}@font-face {    /* 为载入的字体取名字(随意) */    font-family: 'YS';    /* 字体文件地址(相对或者绝对路径都可以) */    /*        src: local("/font/优设好身体.woff2");        会出现红线报错情况。如果路径对。就不要管他        */    src: url(/font/优设好身体.woff2);    /* 定义加粗样式(加粗多少) */    font-weight: normal;    /* 定义字体样式(斜体/非斜体) */    font-style: normal;    /* 定义显示样式 */    font-display: block;}/* 翻页按钮居中 */#pagination {    width: 100%;    margin: auto;}/*    导航栏魔改    一级菜单居中*/#nav .menus_items {    position: absolute !important;    width: fit-content !important;    left: 50% !important;    transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {    display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {    left: -78px;}/* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {    animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {    animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {    animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {    animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {    0% {        text-shadow: #5636ed 0 0 15px;    }    12.5% {        text-shadow: #11ee5e 0 0 15px;    }    25% {        text-shadow: #f14747 0 0 15px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 15px;    }    50% {        text-shadow: #b347f1 0 0 15px;    }    62.5% {        text-shadow: #002afa 0 0 15px;    }    75% {        text-shadow: #ed709b 0 0 15px;    }    87.5% {        text-shadow: #39c5bb 0 0 15px;    }    100% {        text-shadow: #5636ed 0 0 15px;    }}@keyframes light_10px {    0% {        text-shadow: #5636ed 0 0 10px;    }    12.5% {        text-shadow: #11ee5e 0 0 10px;    }    25% {        text-shadow: #f14747 0 0 10px;    }    37.5% {        text-shadow: #f1a247 0 0 10px;    }    50% {        text-shadow: #f1ee47 0 0 10px;    }    50% {        text-shadow: #b347f1 0 0 10px;    }    62.5% {        text-shadow: #002afa 0 0 10px;    }    75% {        text-shadow: #ed709b 0 0 10px;    }    87.5% {        text-shadow: #39c5bb 0 0 10px;    }    100% {        text-shadow: #5636ed 0 0 10px;    }}@keyframes light_5px {    0% {        text-shadow: #5636ed 0 0 5px;    }    12.5% {        text-shadow: #11ee5e 0 0 5px;    }    25% {        text-shadow: #f14747 0 0 5px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 5px;    }    50% {        text-shadow: #b347f1 0 0 5px;    }    62.5% {        text-shadow: #002afa 0 0 5px;    }    75% {        text-shadow: #ed709b 0 0 5px;    }    87.5% {        text-shadow: #39c5bb 0 0 5px;    }    100% {        text-shadow: #5636ed 0 0 5px;    }}/*    与universe.js文件对应，    背景宇宙星光*/#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {    background: linear-gradient(            -45deg,            #e8d8b9,            #eccec5,            #a3e9eb,            #bdbdf0,            #eec1ea    );    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@-moz-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {    background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {    background-color: #3eb8be;    border-radius: 8px;}/* 鼠标样式 */#cursor {    position: fixed;    width: 16px;    height: 16px;    /* 这里改变跟随的底色 */    background: rgb(57, 197, 187);    border-radius: 8px;    opacity: 0.25;    z-index: 10086;    pointer-events: none;    transition: 0.2s ease-in-out;    transition-property: background, opacity, transform;}#cursor.hidden {    opacity: 0;}#cursor.hover {    opacity: 0.1;    transform: scale(2.5);    -webkit-transform: scale(2.5);    -moz-transform: scale(2.5);    -ms-transform: scale(2.5);    -o-transform: scale(2.5);}#cursor.active {    opacity: 0.5;    transform: scale(0.5);    -webkit-transform: scale(0.5);    -moz-transform: scale(0.5);    -ms-transform: scale(0.5);    -o-transform: scale(0.5);}/* 页面样式调节 *//* 首页文章卡片 */#recent-posts > .recent-post-item {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 25px;    border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 18px;    border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border: var(--border-style);    border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {    background: rgba(255, 255, 255, 0.75);    backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {    background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {    background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {    background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {    background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;}[data-theme="dark"] .read-mode div#post {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;}/*哔哩哔哩视频适配*/.aspect-ratio {    position: relative;    width: 90%;    height: auto;    padding-bottom: 75%;    margin: 3% auto;    text-align: center;}.aspect-ratio iframe {    position: absolute;    width: 100%;    height: 86%;    left: 0;    top: 0;}/* 评论区表情放大 */#owo-big {    position: fixed;    align-items: center;    background-color: rgb(255, 255, 255);    border: 1px #aaa solid;    border-radius: 10px;    z-index: 9999;    display: none;    transform: translate(0, -105%);    overflow: hidden;    animation: owoIn 0.3s cubic-bezier(0.42, 0, 0.3, 1.11);}[data-theme=dark] #owo-big {    background-color: #4a4a4a}#owo-big img {    width: 100%;}/* 动画效果代码由 Heo：https://blog.zhheo.com/ 提供 */@keyframes owoIn {    0% {        transform: translate(0, -95%);        opacity: 0;    }    100% {        transform: translate(0, -105%);        opacity: 1;    }}/* 评论提醒 *//* 设置文字内容 :nth-child(1)的作用是选择第几个 */.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(1):before {    content: '输入QQ号会自动获取昵称和头像🐧';}.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(2):before {    content: '收到回复将会发送到您的邮箱📧';}.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(3):before {    content: '可以通过昵称访问您的网站🔗';}/* 当用户点击输入框时显示 */.el-input.el-input--small.el-input-group.el-input-group--prepend:focus-within::before,.el-input.el-input--small.el-input-group.el-input-group--prepend:focus-within::after {    display: block;}/* 主内容区 */.el-input.el-input--small.el-input-group.el-input-group--prepend::before {    /* 先隐藏起来 */    display: none;    /* 绝对定位 */    position: absolute;    /* 向上移动60像素 */    top: -60px;    /* 文字强制不换行，防止left:50%导致的文字换行 */    white-space: nowrap;    /* 圆角 */    border-radius: 10px;    /* 距离左边50% */    left: 50%;    /* 然后再向左边挪动自身的一半，即可实现居中 */    transform: translate(-50%);    /* 填充 */    padding: 14px 18px;    background: #444;    color: #fff;}/* 小角标 */.el-input.el-input--small.el-input-group.el-input-group--prepend::after {    display: none;    content: '';    position: absolute;    /* 内容大小（宽高）为0且边框大小不为0的情况下，每一条边（4个边）都是一个三角形，组成一个正方形。    我们先将所有边框透明，再给其中的一条边添加颜色就可以实现小三角图标 */    border: 12px solid transparent;    border-top-color: #444;    left: 50%;    transform: translate(-50%, -48px);}/* 添加友链按钮 *//* 快速填写格式 */.addBtn {    display: flex;    justify-content: center;    flex-wrap: wrap;}.addBtn button {    transition: .2s;    display: flex;    margin: 5px auto;    color: var(--global-bg);    padding: 15px;    border-radius: 40px;    background: var(--search-result-title);    align-items: center;}button {    padding: 0;    outline: 0;    border: none;    background: 0 0;    cursor: pointer;    touch-action: manipulation;}.fa-solid, .fas {    font-family: "Font Awesome 6 Free";    font-weight: 900;}.addBtn i {    font-size: 1.3rem;    margin-right: 10px;}.addBtn button:hover {    background: var(--theme-color);    color: #fff;}/* 右键菜单 */#rightMenu {    display: none;    position: fixed;    width: 160px;    height: fit-content;    top: 10%;    left: 10%;    /* 菜单面板背景色 */    background-color: var(--card-bg);    /* 菜单面板文字颜色 */    border: 1px solid var(--font-color);    border-radius: 8px;    z-index: 100;}#rightMenu .rightMenu-group {    padding: 7px 6px;}#rightMenu .rightMenu-group:not(:nth-last-child(1)) {    border-bottom: 1px solid var(--font-color);}#rightMenu .rightMenu-group.rightMenu-small {    display: flex;    justify-content: space-between;}#rightMenu .rightMenu-group .rightMenu-item {    height: 30px;    line-height: 30px;    border-radius: 8px;    transition: 0.3s;    color: var(--font-color);}#rightMenu .rightMenu-group.rightMenu-line .rightMenu-item {    display: flex;    height: 40px;    line-height: 40px;    padding: 0 4px;}#rightMenu .rightMenu-group .rightMenu-item:hover {    /* 鼠标悬浮选项颜色 */    background-color: var(--text-bg-hover);}#rightMenu .rightMenu-group .rightMenu-item i {    display: inline-block;    text-align: center;    line-height: 30px;    width: 30px;    height: 30px;    padding: 0 5px;}#rightMenu .rightMenu-group .rightMenu-item span {    line-height: 30px;}#rightMenu .rightMenu-group.rightMenu-line .rightMenu-item * {    height: 40px;    line-height: 40px;}.rightMenu-group.hide {    display: none;}/* 个人卡片头像状态 */.card-info-avatar .author-status-box {    position: absolute;    bottom: 0;    left: calc(100% - 28px);    width: 28px;    height: 28px;    border: 1px solid #d0d7de;    border-radius: 2em;    background-color: #f8f8f8f8;    transition: 0.4s;    overflow: hidden;}[data-theme="dark"] .card-info-avatar .author-status-box {    background-color: #222222f2;    border: 1px solid #5c6060;}.card-info-avatar .author-status-box .author-status {    display: flex;    align-items: center;    justify-content: center;    height: 28px;    padding: 0 5px;}.card-info-avatar .author-status-box:hover {    width: 105px;}.card-info-avatar .author-status-box:hover .author-status span {    width: 105px;    margin-left: 4px;}.card-info-avatar .author-status-box .author-status span {    width: 0;    font-size: 12px;    height: 100%;    overflow: hidden;    text-overflow: ellipsis;    white-space: nowrap;    transition: 0.4s;}.card-widget .card-info-avatar {    display: inline-block;    position: relative;}/* 鼠标放在个人信息卡片，信息卡片彩带 */.author_top:hover {    background: url(https://tuchuang.voooe.cn/images/2023/01/02/snow.gif);    background-size: cover;}/* 头像呼吸灯 */[data-theme="light"] .avatar-img {    animation: huxi_light 4s ease-in-out infinite;}[data-theme="dark"] .avatar-img {    animation: huxi_dark 4s ease-in-out infinite;}@keyframes huxi_light {    0% {        box-shadow: 0px 0px 1px 1px #e9f5fa;    }    50% {        box-shadow: 0px 0px 5px 5px #e9f5fa;    }    100% {        box-shadow: 0px 0px 1px 1px #e9f5fa;    }}@keyframes huxi_dark {    0% {        box-shadow: 0px 0px 1px 1px #39c5bb;    }    50% {        box-shadow: 0px 0px 5px 5px #39c5bb;    }    100% {        box-shadow: 0px 0px 1px 1px #39c5bb;    }}/* 页面滚动条样式 */::-webkit-scrollbar {    width: 8px;    height: 8px;}::-webkit-scrollbar-track {    background-color: rgba(73, 177, 245, 0.2);    border-radius: 2em;}::-webkit-scrollbar-thumb {    background-color: var(--theme-color);    background-image: -webkit-linear-gradient(            45deg,            rgba(255, 255, 255, 0.4) 25%,            transparent 25%,            transparent 50%,            rgba(255, 255, 255, 0.4) 50%,            rgba(255, 255, 255, 0.4) 75%,            transparent 75%,            transparent    );    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: var(--theme-color);}/* 右键菜单 */#rightMenu {    display: none;    position: fixed;    width: 160px;    height: fit-content;    top: 10%;    left: 10%;    /* 菜单面板背景色 */    background-color: var(--card-bg);    /* 菜单面板文字颜色 */    border: 1px solid var(--font-color);    border-radius: 8px;    z-index: 100;}#rightMenu .rightMenu-group {    padding: 7px 6px;}#rightMenu .rightMenu-group:not(:nth-last-child(1)) {    border-bottom: 1px solid var(--font-color);}#rightMenu .rightMenu-group.rightMenu-small {    display: flex;    justify-content: space-between;}#rightMenu .rightMenu-group .rightMenu-item {    height: 30px;    line-height: 30px;    border-radius: 8px;    transition: 0.3s;    color: var(--font-color);}#rightMenu .rightMenu-group.rightMenu-line .rightMenu-item {    display: flex;    height: 40px;    line-height: 40px;    padding: 0 4px;}#rightMenu .rightMenu-group .rightMenu-item:hover {    /* 鼠标悬浮选项颜色 */    background-color: var(--text-bg-hover);}#rightMenu .rightMenu-group .rightMenu-item i {    display: inline-block;    text-align: center;    line-height: 30px;    width: 30px;    height: 30px;    padding: 0 5px;}#rightMenu .rightMenu-group .rightMenu-item span {    line-height: 30px;}#rightMenu .rightMenu-group.rightMenu-line .rightMenu-item * {    height: 40px;    line-height: 40px;}.rightMenu-group.hide {    display: none;}/* 音乐播放器 */#eoMusic-page {    margin-top: -60px;}#eoMusic-page #eo-music {    display: flex;    flex-direction: row-reverse;    background: rgba(0, 0, 0, 0);    border: none;    box-shadow: none;}.bgCls {    filter: blur(63px);    opacity: 0.6;    background-repeat: no-repeat;    background-size: cover;}/* 信息 */#eo-music .aplayer-body {    width: 40%;    height: 75vh;}#eo-music .aplayer-pic {    float: none;    width: 180px;    height: 180px;    border-radius: 12px;    margin: auto;    left: 0;    right: 0;}#eo-music .aplayer-info {    margin: 0 20px 0 20px;    border-bottom: none;}#eo-music .aplayer-info .aplayer-music{    text-align: center;    height: auto;    margin: 15px;}#eo-music .aplayer-info .aplayer-music .aplayer-title, #eo-music .aplayer-info .aplayer-music .aplayer-author{    font-size: 2rem;    font-weight: bold;    color: #fff;}#eo-music .aplayer-info .aplayer-lrc{    height: calc(100vh - 660px);    margin-top: 80px;    -webkit-mask-image: linear-gradient(to bottom,#000,#000,#000,#000,#000,#000,#000,#000,#000,#000,#0000,#0000);}#eo-music .aplayer-info .aplayer-lrc p{    font-size: 14px;    color: #fff;}#eo-music .aplayer-info .aplayer-controller{    position: fixed;    max-width: 1500px;    margin: auto;    left: 0px;    right: 0px;    bottom: 50px;}#eo-music .aplayer-info .aplayer-controller .aplayer-bar-wrap {    margin: 0 160px 0px 150px;}#eo-music .aplayer-info .aplayer-controller .aplayer-thumb {    -webkit-transform: none;    transform: none;    background: #fff !important;}#eo-music .aplayer-info .aplayer-controller .aplayer-played {    background: #fff !important;}/* 控制器 */#eo-music .aplayer-info .aplayer-time .aplayer-icon-back, #eo-music .aplayer-info .aplayer-time .aplayer-icon-play, #eo-music .aplayer-info .aplayer-time .aplayer-icon-forward {    display: inline;    position: fixed;}#eo-music .aplayer-info .aplayer-time .aplayer-icon-menu {    display: none;}#eo-music .aplayer-info .aplayer-time {    position: absolute;    width: 100%;    bottom: 21px;    height: 0px;    display: flex;    justify-content: flex-end;}#eo-music .aplayer-info .aplayer-time .aplayer-volume-wrap .aplayer-volume-bar-wrap {    bottom: 5px;    margin: auto;    left: 8px;    right: 0;}#eo-music .aplayer-info .aplayer-time .aplayer-time-inner {    margin-right: 18px;    margin-top: -8px;}#eo-music .aplayer-info .aplayer-time .aplayer-icon {    width: 2rem;    height: 2rem;    margin-left: 15px;}#eo-music .aplayer-info .aplayer-time .aplayer-icon-back {    position: absolute;    left: 0;}#eo-music .aplayer-info .aplayer-time .aplayer-icon-play {    position: absolute;    left: 40px;}#eo-music .aplayer-info .aplayer-time .aplayer-icon-forward {    position: absolute;    left: 80px;}#eo-music .aplayer-info .aplayer-time .aplayer-icon path {    fill: #fff;    opacity: .8;}#eo-music .aplayer-info .aplayer-time .aplayer-icon path:hover {    fill: #fff;    opacity: 1;}/* 歌曲列表 */#eo-music .aplayer-list {    width: 60%;    max-height: none !important;    height: 100%;}#eo-music ol {    max-height: 75vh !important;    /* height: 100%; */    padding-right: 25px;}#eo-music ol::-webkit-scrollbar-thumb {    background: rgb(0 0 0 / 20%);}#eo-music ol>li {    border-top: 1px solid rgb(233 233 233 / 0%);    font-size: 14px;}#eo-music ol>li span {    color: #fff;}#eo-music ol>li.aplayer-list-light {    background: rgb(255 255 255 / 20%);    border-radius: 6px;}#eo-music ol>li:hover {    background: rgb(255 255 255 / 20%);    border-radius: 6px;}#eo-music ol>li.aplayer-list-light .aplayer-list-cur {    display: none;}#eo-music ol>li span.aplayer-list-author {    opacity: .6;}/* **** 移动端样式 ***** */@media screen and (max-width: 768px) {    /* 歌曲列表 */    #eo-music .aplayer-list {        position: fixed;        z-index: 1002;        width: 100%;        bottom: -76%;        left: 0;        background: var(--sidebar-bg);        height: auto;        border-radius: 15px 15px 0px 0px;        padding: 15px 0px;    }    #eo-music .aplayer-list.aplayer-list-hide {        bottom: 0% !important;    }    #eo-music ol {        max-height: 60vh !important;        padding-right: 0px;    }    #eo-music ol>li {        display: flex;        margin: 0 10px;    }    #eo-music ol>li span {        color: var(--font-color);    }    #eo-music ol>li span.aplayer-list-title {        width: 30%;    }    #eo-music ol>li.aplayer-list-light {        background: #33a673;        padding: 5px 20px;        border-radius: 10px;    }    #eo-music ol>li.aplayer-list-light span {        color: #fff;    }    #eo-music ol>li span.aplayer-list-title{        max-width: 55%;        width: auto;        display: -webkit-box;        -webkit-line-clamp: 1;        overflow: hidden;        -webkit-box-orient: vertical;    }    #eo-music ol>li span.aplayer-list-author {        position: absolute;        right: 10px;        width: auto;        max-width: 35%;        display: -webkit-box;        -webkit-line-clamp: 1;        overflow: hidden;        -webkit-box-orient: vertical;    }    #eo-music ol>li.aplayer-list-light span.aplayer-list-author {        right: 15px;    }    /* 歌词信息 */    #eo-music .aplayer-body {        width: 100%;        position: fixed;        margin: auto;        left: 0;        right: 0;        top: 100px;        /* height: auto; */    }    #eo-music .aplayer-info .aplayer-lrc {        margin-top: 40px;        /* height: 400%; */        height: auto;        max-height: 200%;        min-height: 100%;        -webkit-mask-image: linear-gradient(to bottom,#000,#000,#000,#000,#0000,#0000);    }    #eo-music .aplayer-info .aplayer-lrc p.aplayer-lrc-current {        color: #33a673;    }    /* 控制按键和进度条 */    #eo-music .aplayer-info .aplayer-controller {        bottom: 100px;    }    #eo-music .aplayer-info .aplayer-controller .aplayer-bar-wrap {        margin: 0 30px;    }    #eo-music .aplayer-info .aplayer-time {        bottom: -40px;    }    #eo-music .aplayer-info .aplayer-time .aplayer-time-inner {        position: absolute;        width: 100%;        margin-right: 0;        margin-top: -33px;    }    #eo-music .aplayer-info .aplayer-time .aplayer-time-inner .aplayer-dtime {        position: absolute;        right: 30px;    }    #eo-music .aplayer-info .aplayer-time .aplayer-time-inner .aplayer-ptime {        position: absolute;        left: 35px;    }    #eo-music .aplayer-info .aplayer-time .aplayer-icon-back {        margin: auto;        right: 110px;    }    #eo-music .aplayer-info .aplayer-time .aplayer-icon-play {        margin: auto;        right: 0;        left: 0;    }    #eo-music .aplayer-info .aplayer-time .aplayer-icon-forward {        margin: auto;        left: 110px;        right: 0;    }    #eo-music .aplayer-info .aplayer-time .aplayer-icon-order {        position: absolute;        left: 22px;    }    #eo-music .aplayer-info .aplayer-time .aplayer-icon-loop {        position: absolute;        right: 25px;    }    #eo-music .aplayer-info .aplayer-time .aplayer-icon-menu {        display: inline;        position: absolute;        right: 25px;        top: -90px;    }}/* swiper改动 */@media screen and (min-width: 700px) {    .blog-slider {        height: 300px !important;    }    .blog-slider__img {        width: 50% !important;        height: 105% !important;        border-radius: 45px !important;    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/emoji.js"/>
      <url>/js/emoji.js</url>
      
        <content type="html"><![CDATA[// 如果当前页有评论就执行函数if (document.getElementById('post-comment')) owoBig();// 表情放大function owoBig() {    let flag = 1, // 设置节流阀        owo_time = '', // 设置计时器        m = 3; // 设置放大倍数    // 创建盒子    let div = document.createElement('div'),        body = document.querySelector('body');    // 设置ID    div.id = 'owo-big';    // 插入盒子    body.appendChild(div)    // 构造observer    let observer = new MutationObserver(mutations => {        for (let i = 0; i < mutations.length; i++) {            let dom = mutations[i].addedNodes,                owo_body = '';            if (dom.length == 2 && dom[1].className == 'OwO-body') owo_body = dom[1];                // 如果需要在评论内容中启用此功能请解除下面的注释            // else if (dom.length == 1 && dom[0].className == 'tk-comment') owo_body = dom[0];            else continue;            // 禁用右键（手机端长按会出现右键菜单，为了体验给禁用掉）            if (document.body.clientWidth <= 768) owo_body.addEventListener('contextmenu', e => e.preventDefault());            // 鼠标移入            owo_body.onmouseover = (e) => {                if (flag && e.target.tagName == 'IMG') {                    flag = 0;                    // 移入300毫秒后显示盒子                    owo_time = setTimeout(() => {                        let height = e.path[0].clientHeight * m, // 盒子高                            width = e.path[0].clientWidth * m, // 盒子宽                            left = (e.x - e.offsetX) - (width - e.path[0].clientWidth) / 2, // 盒子与屏幕左边距离                            top = e.y - e.offsetY; // 盒子与屏幕顶部距离                        if ((left + width) > body.clientWidth) left -= ((left + width) - body.clientWidth + 10); // 右边缘检测，防止超出屏幕                        if (left < 0) left = 10; // 左边缘检测，防止超出屏幕                        // 设置盒子样式                        div.style.cssText = `display:flex; height:${height}px; width:${width}px; left:${left}px; top:${top}px;`;                        // 在盒子中插入图片                        div.innerHTML = `<img src="${e.target.src}">`                    }, 300);                }            };            // 鼠标移出隐藏盒子            owo_body.onmouseout = () => { div.style.display = 'none', flag = 1, clearTimeout(owo_time); }        }    })    observer.observe(document.getElementById('post-comment'), { subtree: true, childList: true }) // 监听的 元素 和 配置项}// new Vue({//     data: function () {//         this.$notify({//             title: "索隆提醒你",//             message: "小伙子，扒源记住要遵循GPL协议！",//             position: 'top-left',//             offset: 50,//             showClose: true,//             type: "warning",//             duration: 5000//         });//     }// })]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[// 防抖全局计时器let TT = null;    //time用来控制事件的触发// 防抖函数:fn->逻辑 time->防抖时间function debounce(fn, time) {    if (TT !== null) clearTimeout(TT);    TT = setTimeout(fn, time);}// 复制提醒document.addEventListener("copy", function () {    debounce(function () {        new Vue({            data: function () {                this.$notify({                    title: "copy成功🔍",                    message: "若要转载最好保留原文链接哦，银桑亲你一口",                    position: 'top-left',                    offset: 50,                    showClose: true,                    type: "success",                    duration: 5000                });            }        })    }, 300);})var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(57, 197, 187)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();new Vue({    data: function () {        this.$notify({            title: "索隆提醒你",            message: "小伙子，扒内容记住要遵循GPL协议！",            position: 'top-left',            offset: 50,            showClose: true,            type: "warning",            duration: 5000        });    }})]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/kslink.js"/>
      <url>/js/kslink.js</url>
      
        <content type="html"><![CDATA[var leonus = {    linkCom: e => {        var t = document.querySelector(".el-textarea__inner");        "bf" == e ? (t.value = "```yml\n", t.value += "- name: \n  link: \n  avatar: \n  descr: \n  siteshot: ", t.value += "\n```", t.setSelectionRange(15, 15)) : (t.value = "站点名称：\n站点地址：\n头像链接：\n站点描述：\n站点截图：", t.setSelectionRange(5, 5)), t.focus()    },    owoBig: () => {        if (!document.getElementById("post-comment") || document.body.clientWidth < 768) return;        let e = 1,            t = "",            o = document.createElement("div"),            n = document.querySelector("body");        o.id = "owo-big", n.appendChild(o), new MutationObserver((l => {            for (let a = 0; a < l.length; a++) {                let i = l[a].addedNodes,                    s = "";                if (2 == i.length && "OwO-body" == i[1].className) s = i[1];                else {                    if (1 != i.length || "tk-comment" != i[0].className) continue;                    s = i[0]                }                s.onmouseover = l => {                    e && ("OwO-body" == s.className && "IMG" == l.target.tagName || "tk-owo-emotion" == l.target.className) && (e = 0, t = setTimeout((() => {                        let e = 3 * l.path[0].clientHeight,                            t = 3 * l.path[0].clientWidth,                            a = l.x - l.offsetX - (t - l.path[0].clientWidth) / 2,                            i = l.y - l.offsetY;                        a + t > n.clientWidth && (a -= a + t - n.clientWidth + 10), a < 0 && (a = 10), o.style.cssText = `display:flex; height:${e}px; width:${t}px; left:${a}px; top:${i}px;`, o.innerHTML = `<img src="${l.target.src}">`                    }), 300))                }, s.onmouseout = () => {                    o.style.display = "none", e = 1, clearTimeout(t)                }            }        })).observe(document.getElementById("post-comment"), {            subtree: !0,            childList: !0        })    },};// new Vue({//     data: function () {//         this.$notify({//             title: "索隆提醒你",//             message: "小伙子，扒源记住要遵循GPL协议！",//             position: 'top-left',//             offset: 50,//             showClose: true,//             type: "warning",//             duration: 5000//         });//     }// })]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/music.js"/>
      <url>/js/music.js</url>
      
        <content type="html"><![CDATA[var urlinfo = window.location.pathname;var overtime;qq_musicpage();function qq_musicpage() {    if (urlinfo != '/music/') {        document.querySelector("#web_bg").classList.remove("bgCls");        document.getElementById('web_bg').style.backgroundImage = 'none';        document.getElementById('footer').style.display = 'flex';        document.getElementsByClassName('pace-running')[0].style.background = 'var(--global-bg)';        document.getElementsByTagName('body')[0].style.background = 'var(--global-bg)';        clearInterval(overtime);    }else {        document.querySelector("#web_bg").classList.add("bgCls");        document.getElementById('footer').style.display = 'none';        document.getElementById('content-inner').style.background = 'none';        document.getElementById('page').style.margin = 'auto';        document.getElementById('page').style.background = 'rgba(0,0,0,0)';        document.getElementsByTagName('body')[0].style.background = '#0d0d0d';        overtime = window.setInterval('setOverTime()', '500');    }    document.body.onmousedown = function(event) {        if (event.button == 0) {            var targ = event.target;            var tname = targ.tagName;            var tClassname = targ.classList[1];            var tidname = targ.id;            if (urlinfo == '/music/'){                if (tname == 'svg') {                    var tsvg = targ.parentNode;                    if(tsvg.classList[1] == 'aplayer-icon-menu' || tClassname == 'aplayer-icon-menu') {                        setTimeout(function() {                            document.getElementById('menu-mask').style.display = "block";                            document.getElementById('menu-mask').style.animation = "0.5s ease 0s 1 normal none running to_show";                        }, 100);                    }                }else if (tname == 'path') {                    var tpath = targ.parentNode;                    var tpath2 = tpath.parentNode;                    if(tpath2.classList[1] == 'aplayer-icon-menu') {                        setTimeout(function() {                            document.getElementById('menu-mask').style.display = "block";                            document.getElementById('menu-mask').style.animation = "0.5s ease 0s 1 normal none running to_show";                        }, 100);                    }                }                if (tidname == 'menu-mask') {                    var domHtml = domAplyerList();                    domHtml.classList.remove("aplayer-list-hide");                }            }        }    }}function domAplyerList() {    var htmldom = document.getElementById('eo-music');    var htmldom2 = htmldom.childNodes[3];    return htmldom2;}function setOverTime() {    imgs = document.getElementById('eo-music').getElementsByClassName('aplayer-pic')[0].style.backgroundImage;    document.getElementById('web_bg').style.backgroundImage = imgs;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/randomPost.js"/>
      <url>/js/randomPost.js</url>
      
        <content type="html"><![CDATA[// 发现有时会和当前页面重复，加一个判断function randomPost() {    fetch('/baidusitemap.xml').then(res => res.text()).then(str => (new window.DOMParser()).parseFromString(str, "text/xml")).then(data => {        let ls = data.querySelectorAll('url loc');        while (true) {            let url = ls[Math.floor(Math.random() * ls.length)].innerHTML;            if (location.href == url) continue;            location.href = url;            return;        }    })}// 阅读文章时看了一遍写的代码，发现加个数组和一个遍历完全没必要，改成下面这个即可。// function randomPost() {//     fetch('/baidusitemap.xml').then(res => res.text()).then(str => (new window.DOMParser()).parseFromString(str, "text/xml")).then(data => {//         let ls = data.querySelectorAll('url loc');//         location.href = ls[Math.floor(Math.random() * ls.length)].innerHTML//     })// }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/readPercent.js"/>
      <url>/js/readPercent.js</url>
      
        <content type="html"><![CDATA[window.onscroll = percent;// 执行函数// 页面百分比function percent() {    let a = document.documentElement.scrollTop || window.pageYOffset, // 卷去高度        b = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - document.documentElement.clientHeight, // 整个网页高度        result = Math.round(a / b * 100), // 计算百分比        up = document.querySelector("#go-up") // 获取按钮    if (result <= 95) {        up.childNodes[0].style.display = 'none'        up.childNodes[1].style.display = 'block'        up.childNodes[1].innerHTML = result;    } else {        up.childNodes[1].style.display = 'none'        up.childNodes[0].style.display = 'block'    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/rightmenu.js"/>
      <url>/js/rightmenu.js</url>
      
        <content type="html"><![CDATA[function setMask() {    //设置遮罩    if (document.getElementsByClassName("rmMask")[0] != undefined)        return document.getElementsByClassName("rmMask")[0];    mask = document.createElement('div');    mask.className = "rmMask";    mask.style.width = window.innerWidth + 'px';    mask.style.height = window.innerHeight + 'px';    mask.style.background = '#fff';    mask.style.opacity = '.0';    mask.style.position = 'fixed';    mask.style.top = '0';    mask.style.left = '0';    mask.style.zIndex = 998;    document.body.appendChild(mask);    document.getElementById("rightMenu").style.zIndex = 19198;    return mask;}function insertAtCursor(myField, myValue) {    //IE 浏览器    if (document.selection) {        myField.focus();        sel = document.selection.createRange();        sel.text = myValue;        sel.select();    }    //FireFox、Chrome等    else if (myField.selectionStart || myField.selectionStart == '0') {        var startPos = myField.selectionStart;        var endPos = myField.selectionEnd;        // 保存滚动条        var restoreTop = myField.scrollTop;        myField.value = myField.value.substring(0, startPos) + myValue + myField.value.substring(endPos, myField.value.length);        if (restoreTop > 0) {            myField.scrollTop = restoreTop;        }        myField.focus();        myField.selectionStart = startPos + myValue.length;        myField.selectionEnd = startPos + myValue.length;    } else {        myField.value += myValue;        myField.focus();    }}let rmf = {};rmf.showRightMenu = function (isTrue, x = 0, y = 0) {    let $rightMenu = $('#rightMenu');    $rightMenu.css('top', x + 'px').css('left', y + 'px');    if (isTrue) {        $rightMenu.show();    } else {        $rightMenu.hide();    }}rmf.copyWordsLink = function () {    let url = window.location.href    let txa = document.createElement("textarea");    txa.value = url;    document.body.appendChild(txa)    txa.select();    document.execCommand("Copy");    document.body.removeChild(txa);}rmf.switchReadMode = function () {    const $body = document.body    $body.classList.add('read-mode')    const newEle = document.createElement('button')    newEle.type = 'button'    newEle.className = 'fas fa-sign-out-alt exit-readmode'    $body.appendChild(newEle)    function clickFn() {        $body.classList.remove('read-mode')        newEle.remove()        newEle.removeEventListener('click', clickFn)    }    newEle.addEventListener('click', clickFn)}//复制选中文字rmf.copySelect = function () {    document.execCommand('Copy', false, null);}//回到顶部rmf.scrollToTop = function () {    document.getElementsByClassName("menus_items")[1].setAttribute("style", "");    document.getElementById("name-container").setAttribute("style", "display:none");    btf.scrollToDest(0, 500);}document.body.addEventListener('touchmove', function () {}, { passive: false });function popupMenu() {    window.oncontextmenu = function (event) {        // if (event.ctrlKey) return true;        // 当关掉自定义右键时候直接返回        if (mouseMode == "off") return true;        $('.rightMenu-group.hide').hide();        if (document.getSelection().toString()) {            $('#menu-text').show();        }        if (document.getElementById('post')) {            $('#menu-post').show();        } else {            if (document.getElementById('page')) {                $('#menu-post').show();            }        }        var el = window.document.body;        el = event.target;        var a = /^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&'\*\+,;=.]+$/        if (a.test(window.getSelection().toString()) && el.tagName != "A") {            $('#menu-too').show()        }        if (el.tagName == 'A') {            $('#menu-to').show()            rmf.open = function () {                if (el.href.indexOf("http://") == -1 && el.href.indexOf("https://") == -1 || el.href.indexOf("yisous.xyz") != -1) {                    pjax.loadUrl(el.href)                }                else {                    location.href = el.href                }            }            rmf.openWithNewTab = function () {                window.open(el.href);                // window.location.reload();            }            rmf.copyLink = function () {                let url = el.href                let txa = document.createElement("textarea");                txa.value = url;                document.body.appendChild(txa)                txa.select();                document.execCommand("Copy");                document.body.removeChild(txa);            }        } else if (el.tagName == 'IMG') {            $('#menu-img').show()            rmf.openWithNewTab = function () {                window.open(el.src);                // window.location.reload();            }            rmf.click = function () {                el.click()            }            rmf.copyLink = function () {                let url = el.src                let txa = document.createElement("textarea");                txa.value = url;                document.body.appendChild(txa)                txa.select();                document.execCommand("Copy");                document.body.removeChild(txa);            }            rmf.saveAs = function () {                var a = document.createElement('a');                var url = el.src;                var filename = url.split("/")[-1];                a.href = url;                a.download = filename;                a.click();                window.URL.revokeObjectURL(url);            }        } else if (el.tagName == "TEXTAREA" || el.tagName == "INPUT") {            $('#menu-paste').show();            rmf.paste = function () {                navigator.permissions                    .query({                        name: 'clipboard-read'                    })                    .then(result => {                        if (result.state == 'granted' || result.state == 'prompt') {                            //读取剪贴板                            navigator.clipboard.readText().then(text => {                                console.log(text)                                insertAtCursor(el, text)                            })                        } else {                            Snackbar.show({                                text: '请允许读取剪贴板！',                                pos: 'top-center',                                showAction: false,                            })                        }                    })            }        }        let pageX = event.clientX + 10;        let pageY = event.clientY;        let rmWidth = $('#rightMenu').width();        let rmHeight = $('#rightMenu').height();        if (pageX + rmWidth > window.innerWidth) {            pageX -= rmWidth + 10;        }        if (pageY + rmHeight > window.innerHeight) {            pageY -= pageY + rmHeight - window.innerHeight;        }        mask = setMask();        // 滚动消失的代码和阅读进度有冲突，因此放到readPercent.js里面了        $(".rightMenu-item").click(() => {            $('.rmMask').attr('style', 'display: none');        })        $(window).resize(() => {            rmf.showRightMenu(false);            $('.rmMask').attr('style', 'display: none');        })        mask.onclick = () => {            $('.rmMask').attr('style', 'display: none');        }        rmf.showRightMenu(true, pageY, pageX);        $('.rmMask').attr('style', 'display: flex');        return false;    };    window.addEventListener('click', function () {        rmf.showRightMenu(false);    });}if (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {    popupMenu()}const box = document.documentElementfunction addLongtabListener(target, callback) {    let timer = 0 // 初始化timer    target.ontouchstart = () => {        timer = 0 // 重置timer        timer = setTimeout(() => {            callback();            timer = 0        }, 380) // 超时器能成功执行，说明是长按    }    target.ontouchmove = () => {        clearTimeout(timer) // 如果来到这里，说明是滑动        timer = 0    }    target.ontouchend = () => { // 到这里如果timer有值，说明此触摸时间不足380ms，是点击        if (timer) {            clearTimeout(timer)        }    }}addLongtabListener(box, popupMenu)// 全屏rmf.fullScreen = function () {    if (document.fullscreenElement) document.exitFullscreen();    else document.documentElement.requestFullscreen();}// 右键开关if (localStorage.getItem("mouse") == undefined) {    localStorage.setItem("mouse", "on");}var mouseMode = localStorage.getItem("mouse");function changeMouseMode() {    if (localStorage.getItem("mouse") == "on") {        mouseMode = "off";        localStorage.setItem("mouse", "off");        debounce(function () {            new Vue({                data: function () {                    this.$notify({                        title: "切换右键模式成功🍔",                        message: "当前鼠标右键已恢复为系统默认！",                        position: 'top-left',                        offset: 50,                        showClose: true,                        type: "success",                        duration: 5000                    });                }            })        }, 300);    } else {        mouseMode = "on";        localStorage.setItem("mouse", "on");        debounce(function () {            new Vue({                data: function () {                    this.$notify({                        title: "切换右键模式成功🍔",                        message: "当前鼠标右键已更换为网站指定样式！",                        position: 'top-left',                        offset: 50,                        showClose: true,                        type: "success",                        duration: 5000                    });                }            })        }, 300);    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/share.js"/>
      <url>/js/share.js</url>
      
        <content type="html"><![CDATA[// 分享本页function share_() {    let url = window.location.origin + window.location.pathname    try {        // 截取标题        var title = document.title;        var subTitle = title.endsWith("| Ginkgovio🎧") ? title.substring(0, title.length - 14) : title;        navigator.clipboard.writeText('Ginkgovio🎧的站内分享\n标题：' + subTitle + '\n链接：' + url + '\n欢迎来访！🍭🍭🍭');        new Vue({            data: function () {                this.$notify({                    title: "成功复制信息🎉",                    message: "如果没复制成功那是人问题...",                    position: 'top-left',                    offset: 50,                    showClose: true,                    type: "success",                    duration: 5000                });                // return { visible: false }            }        })    } catch (err) {        console.error('复制失败！', err);    }    // new ClipboardJS(".share", { text: function () { return '标题：' + document.title + '\n链接：' + url } });    // btf.snackbarShow("本页链接已复制到剪切板，快去分享吧~")}// 防抖function share() {    debounce(share_, 300);}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[var now=new Date;function createtime(){now.setTime(now.getTime()+1e3);    var e=new Date("06/01/2023 00:00:00"),t=Math.trunc(234e8+(now-e)/1e3*17),a=(t/1496e5).toFixed(6),o=new Date("06/01/2023 00:00:00"),n=(now-o)/1e3/60/60/24,r=Math.floor(n),i=(now-o)/1e3/60/60-24*r,s=Math.floor(i);1==String(s).length&&(s="0"+s);    var d=(now-o)/1e3/60-1440*r-60*s,l=Math.floor(d);1==String(l).length&&(l="0"+l);    var g=(now-o)/1e3-86400*r-3600*s-60*l,b=Math.round(g);1==String(b).length&&(b="0"+b);    let c="";c=s<18&&s>=9?`<img class='boardsign' src='https://img.shields.io/badge/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94-%E6%91%86%E7%83%82%E4%B8%AD-ff69b4' title='阿姆斯特朗闪光回旋炮!'><br> <div style="font-size:13px;font-weight:bold">小破站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 事物的历史由其本身写就，事物的诞生就开始了对自己历史的书写 🚀</div>`:`<img class='boardsign' src='https://img.shields.io/badge/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94-%E4%B8%8D%E6%91%86%E7%83%82-brightgreen' title='阿姆斯特朗闪光回旋炮!'><br> <div style="font-size:13px;font-weight:bold">小破站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 事物的历史由其本身写就，事物的诞生就开始了对自己历史的书写 🚀</div>`,document.getElementById("workboard")&&(document.getElementById("workboard").innerHTML=c)}setInterval((()=>{createtime()}),1e3);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>番剧</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<p><div class="addBtn"><button onclick="leonus.linkCom()"><i class="fa-solid fa-circle-plus"></i>快速申请 (默认样式)</button> <button onclick="leonus.linkCom(&quot;bf&quot;)"><i class="fa-solid fa-circle-plus"></i>快速申请 (Butterfly)</button></div></p><p><link rel="stylesheet" href="/css/kslink.css"></p><script src="/js/kslink.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
